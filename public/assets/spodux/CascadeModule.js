'use strict';

class CascadeModule extends StateModule {
  
  processState(stateChange) {
    this._rememberStateChange(stateChange);
    
    // iterate module observers
    this.observers.forEach(observer => {
      // parse observer into object with observer handler and dependencies
      var { handler, dependencies } = this._parseObserver(observer);
      
      // determine if the observer should be called
      var observerTriggered = this._dependentOnStateChange(dependencies, stateChange);
      
      // no dependencies on the stateChange. skip the observer
      if (!observerTriggered) return;
      
      // resolve dependencies
      var args = this._resolveDependencies(dependencies);
      
      // save observer generated stateChange branch
      var observerResult = this[handler](...args);
      
      // observer function returned falsey value
      if (!observerResult) {
        if (this.settings && this.settings.consoleLogging)
          console.log(`${handler} observer returned empty value`);
          
        return;
      }
      
      // merge stateChange with a new branch generated by the observer
      Object.assign(stateChange, observerResult);
    });
    
    this._forgetStateChange();
  }
  
  _parseObserver(observer) {
    // trim spaces
    observer = observer.replace(/[\r\n\ ]/g, '');
    
    return {
      // observer handler
      handler: observer.slice(0, observer.indexOf('(')),
      // observer dependencies
      dependencies: observer.slice(observer.indexOf('(') + 1, observer.indexOf(')')).split(',')
    };
  }
  
  _dependentOnStateChange(dependencies, stateChange) {
    return dependencies.some(dependency => {
      
      // handle complex dependency
      if (dependency.indexOf(":") !== -1) {
        // parse complex dependency
        var dependencySpecifiers = this._parseDependencySpecifiers(dependency);
        dependency = this._fixComplexDependency(dependency);
        
        // dependency path
        var path = this._getPropPath(dependency);
        
        // check if the path is present in the stateChange
        if (path in stateChange) {
          var oldState = this.resolveStatePath(path);
          
          var result = dependencySpecifiers.some(specifier => {
          	if (stateChange[path][specifier] !== oldState[specifier]) return true;

          	return false;
          });
          
          if (result)
            return true;
          else
            return false;
        }
        
        // not in stateChange
        return false;
      }
      // handle simple dependency
      else {
        // dependency path
        var path = this._getPropPath(dependency);
        
        // check if the path is present in the stateChange
        if (path in stateChange)
          return true;
        
        return false;
      }
    });
  }
  
  _resolveDependencies(dependencies) {
    // [dependency1, dependency2, ...] => [stateValue1, stateValue2, ...]
    return dependencies.map(dependency => {
      
      if (dependency.indexOf(":") !== -1)
        dependency = this._fixComplexDependency(dependency);
      
      var path = this._getPropPath(dependency);
      
      return this.resolvePath(path);
    });
  }
  
  _rememberStateChange(stateChange) {
    this._stateChange = stateChange;
  }
  
  _forgetStateChange() {
    delete this._stateChange;
  }
  
  resolvePath(path) {
    // if dependency is present in the stateChange
    if (path in this._stateChange)
      // pull it from there
      return this._stateChange[path];
    // dependency is not in the stateChange
    else
      // take it from the state
      return this.resolveStatePath(path);
  }
  
  _parseDependencySpecifiers(dependency) {
    return dependency.split(":").slice(1);
  }
  
  _fixComplexDependency(dependency) {
    return dependency.slice(0, dependency.indexOf(":"));
  }
  
}