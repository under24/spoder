'use strict';

class CascadeModule extends StateModule {
  
  process(newState) {
    // iterate module observers
    this.observers.forEach(observer => {
      // parse observer into object with observer handler and dependencies
      var { handler, dependencies } = this._parseObserver(observer);
      
      // determine if the observer should be called
      var observerTriggered = this._dependentOnNewState(dependencies, newState);
      
      // no dependencies on the newState. skip the observer
      if (!observerTriggered) return;
      
      // resolve dependencies
      var args = this._resolveDependencies(dependencies, newState);
      
      // save observer generated newState branch
      var observerResult = this[handler](...args);
      
      // observer function returned falsey value
      if (!observerResult) {
        console.log(`${handler} observer returned empty value`);
        return;
      }
      
      // merge newState with a new branch generated by the observer
      Object.assign(newState, observerResult);
    });
  }
  
  _parseObserver(observer) {
    // trim spaces
    observer = observer.replace(/ /g, '');
    
    return {
      // observer handler
      handler: observer.slice(0, observer.indexOf('(')),
      // observer dependencies
      dependencies: observer.slice(observer.indexOf('(') + 1, observer.indexOf(')')).split(',')
    };
  }
  
  _dependentOnNewState(dependencies, newState) {
    return dependencies.some(dependency => {
      // dependency path
      var path = this._getPropPath(dependency);
      
      // check if the path is present in the newState
      if (path in newState) 
        return true;
      
      return false;
    });
  }
  
  _resolveDependencies(dependencies, newState) {
    // [dependency1, dependency2, ...] => [stateValue1, stateValue2, ...]
    return dependencies.map(dependency => {
      var path = this._getPropPath(dependency);
      
      // if dependency is present in the newState
      if (path in newState)
        // pull it from there
        return newState[path];
      // dependency is not in the newState  
      else
        // take it from the state
        return this.resolvePath(path);
    });
  }
  
}