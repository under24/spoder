<link rel="import" href="../../../../../bower_components/polymer/polymer-element.html">

<dom-module id="digital-joystick">
  <template>
    <style>
      :host {
        display: inline-block;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }
      #joystickContainer {
        border: 1px dashed rgba(0, 0, 0, 0.5);
        border-radius: 100%;
        width: 100%;
        height: 100%;
        box-sizing: border-box;
      }
      /* vertical line */
      :host([debug]) #joystickContainer::before {
        content: '';
        display: inline-block;
        position: absolute;
        left: 50%;
        top: 0px;
        bottom: 0px;
        border-left: 1px dashed rgba(0, 0, 0, 0.5);
        transform: translateX(-50%);
      }
      /* horizontal line */
      :host([debug]) #joystickContainer::after {
        content: '';
        display: inline-block;
        position: absolute;
        left: 0px;
        right: 0px;
        top: 50%;
        border-top: 1px dashed rgba(0, 0, 0, 0.5);
        transform: translateY(-50%);
      }
      #rocker {
        display: inline-block;
        background-color: rgba(255, 255, 255, 0.8);
        border: 1px dotted black;
        border-radius: 100%;
        position: absolute;
        transform: translate(-50%, -50%);
        z-index: 7;
      }
      /* rocker center dot */
      :host([debug]) #rocker::before {
        content: '';
        display: inline-block;
        position: absolute;
        top: 50%;
        left: 50%;
        width: 4px;
        height: 4px;
        background-color: rgba(0, 0, 0, 0.5);
        transform: translate(-50%, -50%);
        border-radius: 100%;
      }
      #centerPoint {
        position: absolute;
      }
      /* center dot */
      :host([debug]) #centerPoint::before {
        content: '';
        position: absolute;
        height: 6px;
        width: 6px;
        background-color: red;
        transform: translate(-50%,-50%);
        border-radius: 100%;
        top: 50%;
        left: 50%;
      }
      :host([debug]) #boundaryCircle {
        position: absolute;
        height: 6px;
        width: 6px;
        background-color: red;
        transform: translate(-50%,-50%);
        border-radius: 100%;
      }
      :host([debug]) #centerGuideline {
        transform-origin: left;
        border-top: 1px dashed black;
        position: absolute;
        top: 50%;
        left: 50%;
      }
      .debug-block {
        position: absolute;
        right: 0px;
        top: 0px;
        transform: translateX(100%);
      }
    </style>
    <div id="joystickContainer">
      <div id="centerPoint">
        <div id="centerGuideline"></div>
      </div>
      <div id="rocker"></div>
      <div id="boundaryCircle"></div>
      
      <div class="debug-block">
        <div>
          <label>
            <input type="checkbox" checked="{{debug::change}}">
            Debug
          </label>
        </div>
        <div>
          <label>
             <input type="checkbox" checked="{{restrict::change}}">
             Restrict
          </label>
        </div>
        <template is="dom-if" if="[[debug]]" restamp>
          <div>Size: [[size]]</div>
          <div>Radius: [[radius]]</div>
          <div>RockerX: [[rockerX]]</div>
          <div>RockerY: [[rockerY]]</div>
          <div>Angle: [[angle]]</div>
          <div>DiffX: [[diffX]]</div>
          <div>DiffY: [[diffY]]</div>
          <div>Dist in pxls: [[distInPxls]]</div>
          <div>Dist in pct: [[distInPct]]</div>
          <div>BoundaryX: [[boundaryX]]</div>
          <div>BoundaryY: [[boundaryY]]</div>
          <div>X Shift: [[xShift]]</div>
          <div>Y Shift: [[yShift]]</div>
        </template>
      </div>
    </div>
    
  </template>

  <script>
    class digitalJoystick extends ReduxMixin(Polymer.Element) {
      static get is() { return 'digital-joystick'; }
      static get properties() {
        return {
          size: {
            type: Number,
            value: 300
          },
          radius: {
            type: Number,
            computed: 'computeRadius(size)'
          },
          restrict: {
            type: Boolean,
            value: true
          },
          rockerSize: {
            type: Number,
            value: 30
          },
          rockerX: {
            type: Number,
            observer: 'redrawX'
          },
          rockerY: {
            type: Number,
            observer: 'redrawY'
          },
          xShift: {
            type: Number,
            notify: true
          },
          yShift: {
            type: Number,
            notify: true
          },
          centerX: Number,
          centerY: Number,
          debug: {
            type: Boolean,
            value: false,
            reflectToAttribute: true,
          },
          // debug values
          // diffX: Number,
          // diffY: Number,
          // angle: Number,
          // distInPxls: Number,
          // distInPct: Number,
          // boundaryX: Number,
          // boundaryY: Number
        };
      }
      
      connectedCallback() {
        super.connectedCallback();
        
        this.calcSizeAndRenderView();
        this.attachHandler();
      }
      
      calcSizeAndRenderView() {
        this.style.width = this.style.height = this.size + 'px';
        
        this.centerY = this.centerX = this.radius;
        
        this.centerRocker();
        
        this.$.centerPoint.style.left = this.centerX + 'px';
        this.$.centerPoint.style.top = this.centerY + 'px';
        
        // set rocker size
        this.$.rocker.style.width = this.rockerSize + '%';
        this.$.rocker.style.height = this.rockerSize + '%';
      }
      
      attachHandler() {
        this.$.rocker.onmousedown = (e) => {
          let clickCoords = {x: e.pageX, y: e.pageY};
          let initCoords = {x: this.rockerX, y: this.rockerY};
          document.onmousemove = (e) => {
            let dragX = e.pageX - clickCoords.x;
            let dragY = e.pageY - clickCoords.y;
            
            // same values -> bail out
            if (dragX === 0 && dragY === 0) return;
            
            let rx = initCoords.x + dragX;
            let ry = initCoords.y + dragY;
            
            // render joystick
            this.renderJoystick(rx, ry);
            
            e.preventDefault();
            e.stopPropagation();
          };
          document.onmouseup = () => {
            document.onmousemove = null;
            document.onmouseup = null;
          }
          e.preventDefault();
          e.stopPropagation()
        }
        this.$.rocker.ondblclick = () => {
          this.centerRocker();
        }
      }
      
      redrawX(x) {
        this.$.rocker.style.left = x + 'px';
      }
      
      redrawY(y) {
        this.$.rocker.style.top = y + 'px';
      }
      
      drawCenterGuideline(distInPxls, screenAngle) {
        this.$.centerGuideline.style.width = distInPxls + 'px';
        this.$.centerGuideline.style.transform = 'rotate(' + screenAngle + 'deg)';
      }
      
      drawBoundaryBall(bx, by) {
        this.$.boundaryCircle.style.left = bx + 'px';
        this.$.boundaryCircle.style.top = by + 'px';
      }
      
      centerRocker() {
        // rockerX, rockerY
        this.renderJoystick(this.radius, this.radius);
      }
      
      computeRadius(size) {
        return this.size / 2;
      }
      
      renderJoystick(rx, ry) {
        let rockerData = this.calcRockerData(rx, ry);
        
        // recalc if the rx ry are outside the boundaries
        if (this.restrict && rockerData.distInPxls > this.radius) {
          rockerData = this.calcRockerData(rockerData.bx, rockerData.by);
        }
        
        // redraw rocker
        this.rockerX = rockerData.rx;
        this.rockerY = rockerData.ry;
        
        // set main values
        this.xShift = rockerData.xShift;
        this.yShift = rockerData.yShift;
        
        // set debug data && redraw ui
        if (this.debug) this.pushDebugData(rockerData);
        
        
        // TODO
        // remove dispatch && its function
        this.dispatchData(rockerData.xShift, rockerData.yShift);
      }
      
      calcRockerData(rx, ry) {
        // rockerX - centerX, rockerY - centerY
        let diff = this.getDiffXY(rx, ry);
        
        // distance from center to rocker in pxls
        let distInPxls = this.getDistanceInPixels(diff);

        // distance from center to rocker in pct
        let distInPct = this.getDistanceInPct(distInPxls);
        
        // y point in pct from center
        let xShift = this.getShiftCoords(rx);
        // y point in pct from center
        let yShift = this.getShiftCoords(ry);
        
        // calc angle for calculations
        let angle = this.getAngle(diff);
        
        // convert angle to screen angle
        let screenAngle = this.getScreenAngle(angle);
        
        // boundary ball
        let bx = this.getBoundaryX(this.centerX, angle);
        let by = this.getBoundaryY(this.centerY, angle);
        
        return {
          rx,
          ry,
          diff,
          distInPxls,
          distInPct,
          xShift,
          yShift,
          screenAngle,
          bx,
          by
        }
      }
      
      getDiffXY(rx, ry) {
        return {
          x: rx - this.centerX,
          y: ry - this.centerY
        }
      }
      
      getDistanceInPixels(diff) {
        return Utils.getDistance(diff.x, diff.y);
      }
      
      getDistanceInPct(pxls) {
        return pxls / (this.radius / 100);
      }
      
      getShiftCoords(coord) {
        return (this.radius - coord) / (this.radius / 100);
      }
      
      getAngle(diff) {
        return Math.atan2(diff.y, diff.x);
      }
      
      getScreenAngle(angle) {
        return (angle > 0 ? angle : (2 * Math.PI + angle)) * 360 / (2 * Math.PI);
      }
      
      getBoundaryX(cx, angle) {
        return cx + this.radius * Math.cos(angle);
      }
      
      getBoundaryY(cy, angle) {
        return cy + this.radius * Math.sin(angle);
      }
      
      pushDebugData(rockerData) {
        this.drawBoundaryBall(rockerData.bx, rockerData.by);
        this.drawCenterGuideline(rockerData.distInPxls, rockerData.screenAngle);
        this.diffX = rockerData.diff.x;
        this.diffY = rockerData.diff.y;
        this.distInPxls = rockerData.distInPxls;
        this.distInPct = rockerData.distInPct;
        this.angle = rockerData.screenAngle;
        this.boundaryX = rockerData.bx;
        this.boundaryY = rockerData.by;   
      }
      
      dispatchData(xShift, yShift) {
        let payload = {};
        // left - right
        if (xShift > 0) {
          payload.sagittalBaseYLeftTiltModifier = xShift;
          payload.sagittalBaseYRightTiltModifier = xShift * -1;
        } else if (xShift < 0) {
          payload.sagittalBaseYRightTiltModifier = xShift * -1;
          payload.sagittalBaseYLeftTiltModifier = xShift;
        }
        
        // top - bottom
        if (yShift > 0) {
          payload.sagittalBaseYFrontTiltModifier = yShift;
          payload.sagittalBaseYBackTiltModifier = yShift * -1;
        } else if (yShift < 0) {
          payload.sagittalBaseYBackTiltModifier = yShift * -1;
          payload.sagittalBaseYFrontTiltModifier = yShift;
        }
        
        if (yShift === 0 && xShift === 0) {
          payload.sagittalBaseYBackTiltModifier = 0;
          payload.sagittalBaseYFrontTiltModifier = 0;
          payload.sagittalBaseYLeftTiltModifier = 0;
          payload.sagittalBaseYRightTiltModifier = 0;
        }
        
        store.dispatch({type: "BASE_Y_TILT_MODIFIER_CHANGED", payload}); 
      }

    }

    window.customElements.define(digitalJoystick.is, digitalJoystick);
  </script>
</dom-module>
