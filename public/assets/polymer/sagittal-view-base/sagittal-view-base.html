<link rel="import" href="../../../../../bower_components/polymer/polymer-element.html">

<dom-module id="sagittal-view-base">
  <template>
    <style>
      #base {
        height: 1px;
        width: 1px;
        position: absolute;
      }
      :host([side=left]) #base {
        right: initial !important;
      }
      :host([side=right]) #base {
        left: initial !important;
      }
      #base::after {
        content: '';
        background: rgba(0, 0, 255, 0.25);
        width: 20px;
        height: 20px;
        display: inline-block;
        transform: translate(-50%,-50%);
        border-radius: 100%;
      }
      #femur {
        position: absolute;
        top: 0px;
        height: 1px;
        background-color: black;
        z-index: 1;
        pointer-events: none;
      }
      :host([side=left]) #femur {
        transform-origin: left;
        left: 0px;
      }
      :host([side=right]) #femur {
        transform-origin: right;
        right: 0px;
      }
      #tibia {
        height: 1px;
        background-color: black;
        position: absolute;
        top: 0px;
      }
      :host([side=left]) #tibia {
        transform-origin: left;
        left: 100%;
      }
      :host([side=right]) #tibia {
        transform-origin: right;
        right: 100%;
      }
      #reachRadius {
        background-color: rgba(255, 0, 0, 0.04);
        display: inline-block;
        transform: translate(0%, -50%);
        position: absolute;
        pointer-events: none;
      }
      :host([side=left]) #reachRadius {
        border-bottom-left-radius: initial !important;
        border-top-left-radius: initial !important;
        left: 0px;
      }
      :host([side=right]) #reachRadius {
        border-bottom-right-radius: initial !important;
        border-top-right-radius: initial !important;
        right: 0px;
      }
      #baseInvalidRange {
        background-color: white;
        border-radius: 100%;
        position: absolute;
        border: 1px solid transparent;
        transform: translate(-50%, -50%) rotateZ(-45deg);
        pointer-events: none;
        box-sizing: border-box;
      }
      :host([side=left]) #baseInvalidRange {
        border-right-color: red;
        border-bottom-color: red;
      }
      :host([side=right]) #baseInvalidRange {
        border-left-color: red;
        border-top-color: red;
      }
      #distanceLine {
        border-top: 1px dashed black;
        position: absolute;
      }
      :host([side=left]) #distanceLine {
        transform-origin: left;
        left: 0px;
      }
      :host([side=right]) #distanceLine {
        transform-origin: right;
        right: 0px;
      }
      #transverseReachEnd, #transverseReachBeginning, #boundaryBall {
        background-color: black;
        height: 10px;
        width: 10px;
        display: inline-block;
        position: absolute;
        border-radius: 100%;
        transform: translate(-50%, -50%)
      }
      #floor {
        display: inline-block;
        border-top: 1px dashed rgba(255, 0, 0, 0.5);
        width: 100%;
        position: absolute;
      }
    </style>
    
    <div id="base">
      <div id="femur">
        <div id="tibia"></div>
      </div>
      
      <div id="reachRadius"></div>
      <div id="baseInvalidRange"></div>
      
      <div id="distanceLine"></div>
    </div>
    
    <div id="floor"></div>
    <div id="transverseReachEnd"></div>
    <div id="transverseReachBeginning"></div>
    <div id="boundaryBall"></div>
  </template>

  <script>
    class sagittalViewBase extends ReduxMixin(Polymer.Element) {
      static get is() { return 'sagittal-view-base'; }
      static get properties() {
        return {
          side: {
            reflectToAttribute: true,
            observer: 'observeSide'
          },
          x: {
            observer: 'observeBaseX'
          },
          y: {
            observer: 'observeBaseY'
          },
          femurScreenAngle: {
            observer: 'observeFemurScreenAngle'
          },
          tibiaScreenAngle: {
            observer: 'observeTibiaScreenAngle'
          },
          femurLength: {
            observer: 'observeFemurLength'
          },
          tibiaLength: {
            observer: 'observeTibiaLength'
          },
          impossibleRange: {
            observer: 'observeImpossibleRange'
          },
          reachRadius: {
            observer: 'observeReachRadius'
          },
          distanceLine: {
            observer: 'observeDistanceLine'
          },
          boundaryBall: {
            observer: 'observerBoundaryBall'
          },
          transverseReachPoints: {
            observer: 'observeTransverseReachPoints'
          },
          floorLevel: {
            observer: 'observeFloorLevel'
          },
          output: {
            notify: true
          }
        };
      }
      
      connectedCallback() {
        super.connectedCallback();
        
        this.$.base.onmousedown = (e) => {
          this.clickCoords = {x: e.pageX,y: e.pageY};

          document.onmousemove = (e) => {
            let diffX = this.clickCoords.x - e.pageX;
            let diffY = this.clickCoords.y - e.pageY;
            
            // the position is the same
            if (diffX === 0 && diffY === 0) return;
            
            // filter out 0 value
            let payload = {};
            if (diffX !== 0) {
              switch (this.side) {
                case 'left':
                  payload.x = diffX; break;
                case 'right':
                  payload.x = -diffX; break;
              }
              this.clickCoords.x = e.pageX;
            }
            if (diffY !== 0) {
              payload.y = diffY;
              this.clickCoords.y = e.pageY;
            }
            
            // export data to the upper component
            this.output = payload;
            
            e.preventDefault();
            e.stopPropagation();
          };
          document.onmouseup = () => {
            document.onmousemove = null;
            document.onmouseup = null;
          }
          e.preventDefault();
          e.stopPropagation()
        }
      }
      
      redrawX(x) {
        switch (this.side) {
          case 'left':
            this.$.base.style.left = `${x}px`; return;
          case 'right':
            this.$.base.style.right = `${x}px`; return;
        }
      }
      
      redrawY(y) {
        this.$.base.style.top = `${y}px`;
      }
      
      observeFemurScreenAngle(newAngle) {
        switch (this.side) {
          case 'left':
            this.$.femur.style.transform = `rotate(${newAngle}deg)`; return;
          case 'right':
            this.$.femur.style.transform = `rotate(${Utils.flipNumber(newAngle)}deg)`; return;
        }
      }
      
      observeTibiaScreenAngle(newAngle) {
        switch (this.side) {
          case 'left':
            this.$.tibia.style.transform = `rotate(${newAngle}deg)`; return;
          case 'right':
            this.$.tibia.style.transform = `rotate(${Utils.flipNumber(newAngle)}deg)`; return;
        }
      }
      
      redrawSide() {
        switch(this.side) {
          case 'left':
            this.$.reachRadius.style.borderBottomRightRadius = `${this.reachRadius * 2}px`;
            this.$.reachRadius.style.borderTopRightRadius = `${this.reachRadius * 2}px`;
            this.redrawX(this.x);
            break;
          case 'right':
            this.$.reachRadius.style.borderBottomLeftRadius = `${this.reachRadius * 2}px`;
            this.$.reachRadius.style.borderTopLeftRadius = `${this.reachRadius * 2}px`;
            this.redrawX(this.x);
            break;
        }
        this.observeFemurScreenAngle(this.femurScreenAngle);
        this.observeTibiaScreenAngle(this.tibiaScreenAngle);
      }
      
      observeFemurLength(femurLength) {
        this.$.femur.style.width = `${femurLength}px`;
      }
      
      observeTibiaLength(tibiaLength) {
        this.$.tibia.style.width = `${tibiaLength}px`;
      }
      
      observeReachRadius(reachRadius) {
        this.$.reachRadius.style.width = `${reachRadius}px`;
        this.$.reachRadius.style.height = `${reachRadius * 2}px`;
      }
      
      observeImpossibleRange(impRange) {
        this.$.baseInvalidRange.style.width = `${impRange * 2}px`;
        this.$.baseInvalidRange.style.height = `${impRange * 2}px`;
      }
      
      observeDistanceLine(data) {
        this.$.distanceLine.style.width = `${data.distance}px`;
        
        switch (this.side) {
          case 'left':
            this.$.distanceLine.style.transform = `rotate(${data.angle}deg)`; return;
          case 'right':
            this.$.distanceLine.style.transform = `rotate(-${data.angle}deg)`; return;
        }
      }
      
      observerBoundaryBall(data) {
        this.$.boundaryBall.style.left = `${data.x}px`;
        this.$.boundaryBall.style.top = `${data.y}px`;
      }
      
      observeTransverseReachPoints(data) {
        this.$.transverseReachEnd.style.left = `${data.endX}px`;
        this.$.transverseReachEnd.style.top = `${data.endY}px`;
        
        this.$.transverseReachBeginning.style.left = `${data.possibleX}px`;
        this.$.transverseReachBeginning.style.top = `${data.possibleY}px`;
      }
      
      observeFloorLevel(data) {
        this.$.floor.style.top = `${data}px`;
      }

    }
    sagittalViewBase.prototype.observeBaseX = sagittalViewBase.prototype.redrawX;
    sagittalViewBase.prototype.observeBaseY = sagittalViewBase.prototype.redrawY;
    sagittalViewBase.prototype.observeSide = sagittalViewBase.prototype.redrawSide;

    window.customElements.define(sagittalViewBase.is, sagittalViewBase);
  </script>
</dom-module>
