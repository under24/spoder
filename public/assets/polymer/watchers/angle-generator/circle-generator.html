<dom-module id="circle-generator">
  <script>
    class circleGenerator extends ReduxMixin(Polymer.Element) {
      static get is() { return 'circle-generator'; }
      static get properties() {
        return {
          turnJoystick: {
            statePath: 'movement.turnJoystick',
            // observer: 'observeTurnJoystick'
          },
          misc: {
            statePath: 'misc'
          },
          coords: {
            statePath: 'coords'
          },
          base: {
            statePath: 'base'
          },
          metaData: {
            statePath: 'metaData'
          },
          circles: {
            statePath: 'movement.circles'
          }
        };
      }
      
      processNewCircle(legId, transverseReachRadius, coords, baseDirection = this.base.direction, baseCenterCoords = this.base.centerCoords) {
        // circle fluent diameter and radius
        var fluentDiameter = transverseReachRadius - this.metaData.impossibleRange,
            fluentRadius = fluentDiameter / 2;
            
        // circle solid diameter and radius
        var solidDiameter = 160,
            solidRadius = 80;
        
        // turn joystick is centered (neutral)
        if (!this.turnJoystick.normalizedX) {
          var fluentBaseX = coords.transverseBaseX,
              fluentBaseY = coords.transverseBaseY;
        }
        // turn joystick is not centered (active)
        else {
          let rotationAngle = MU.flipNumber(this.turnJoystick.normalizedX),
              rotatedCoords = { x: coords.transverseBaseX, y: coords.transverseBaseY };
          
          var { x: fluentBaseX, y: fluentBaseY } = MU.rotateCoords(baseCenterCoords, rotatedCoords, rotationAngle);
        }
        
        // calc fluent x/y
        {
          let solidDistance = this.calcSolidDistance(solidRadius);
          let fluentAngle = this.calcFluentAngle(this.base.coxaAttachmentAngles[legId], baseDirection);
          
          var { x: fluentX, y: fluentY } = MU.getCoordsFromDistanceAndAngle(fluentBaseX, fluentBaseY, fluentAngle, solidDistance);
        }
        // calc solid x/y
        {
          let fluentDistance = this.calcFluentDistance(transverseReachRadius);
          let solidAngle = this.calcSolidAngle(this.base.coxaAttachmentAngles[legId], baseDirection);
          
          var { x: solidX, y: solidY } = MU.getCoordsFromDistanceAndAngle(coords.transverseBaseX, coords.transverseBaseY, solidAngle, fluentDistance);
        }
        
        return {
          fluentTransverseBaseX: fluentBaseX,
          fluentTransverseBaseY: fluentBaseY,
          fluentX,
          fluentY,
          fluentDiameter,
          fluentRadius,
          solidX,
          solidY,
          solidDiameter,
          solidRadius
        };
      }
      
      calcFluentAngle(coxaAttachmentAngle, baseDirection) {
        return coxaAttachmentAngle + baseDirection - this.turnJoystick.normalizedX;
      }
      
      calcSolidAngle(coxaAttachmentAngle, baseDirection) {
        return coxaAttachmentAngle + baseDirection;
      }
      
      // distance to the center of the circle + offset from impossible range
      calcFluentDistance(transverseReachRadius) {
        return (this.metaData.impossibleRange + transverseReachRadius) / 2;
      }
      
      // for when the leg is raised. the circle should have solid position so it does not move when the leg is raised
      calcSolidDistance(solidRadius) {
        return this.metaData.impossibleRange + solidRadius;
      }
      
      sieveOutAndGatherUp(legId, circle, payload) {
        // filter in unique values and add them to the payload[legId] object
        GU.sieveOutAndGatherUp(circle, this.circles[legId], payload, legId);
      }
      
      dispatchCirles(payload) {
        // empty payload object
        if (Object.keys(payload).length === 0) return;
        
        store.dispatch({ type: "MOVEMENT_CIRCLES_CHANGED_BATCHED", payload });
      }
      
      observeTurnJoystick(newValue, oldValue) {
        // skip init because circles will be generated in the observeCoords function
        if (oldValue === undefined) return;
        
        var payload = {};
        
        for (let legId = 1; legId <= 6; legId++) {
          let circle = this.processNewCircle(legId, this.misc[legId].transverseReachRadius, this.coords[legId]);
          this.sieveOutAndGatherUp(legId, circle, payload);
        }
        
        this.dispatchCirles(payload);
      }

    }
    window.customElements.define(circleGenerator.is, circleGenerator);
  </script>
</dom-module>