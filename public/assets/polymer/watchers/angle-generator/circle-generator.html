<dom-module id="circle-generator">
  <script>
    class circleGenerator extends ReduxMixin(Polymer.Element) {
      static get is() { return 'circle-generator'; }
      static get properties() {
        return {
          turnJoystick: {
            statePath: 'movement.turnJoystick',
            observer: 'observeTurnJoystick'
          },
          misc: {
            statePath: 'misc'
          },
          coords: {
            statePath: 'coords'
          },
          base: {
            statePath: 'base'
          },
          metaData: {
            statePath: 'metaData'
          },
          circles: {
            statePath: 'movement.circles'
          }
        };
      }
      
      processNewCircle(legId, transverseReachRadius, coords, baseDirection = this.base.direction, baseCenterCoords = this.base.centerCoords) {
        var circleDiameter = transverseReachRadius - this.metaData.impossibleRange,
            tbx = coords.transverseBaseX,
            tby = coords.transverseBaseY,
            side = GU.getLegSide(legId),
            coxaAttachment = this.base.coxaAttachmentAngles[legId],
            // sum up coxaAttachment + baseDirection - turnJoystick
            angle = this.calcAngle(side, coxaAttachment, baseDirection),
            // distance to the center of the circle + offset from impossible range
            // distance = (transverseReachRadius + this.metaData.impossibleRange) / 2;
            // for when the leg is raised. the circle should have solid position so it does not move when the leg is raised
            distance = this.metaData.impossibleRange + 80;
        
        // if the turn joystick is not centered (!== 0) find circleCenterCoords + solidX/Y 
        if (this.turnJoystick.normalizedX) {
          // turn base coords
          var { x: turnedBaseX, y: turnedBaseY } = RU.getRotatedCoords(baseCenterCoords, MU.flipNumber(this.turnJoystick.normalizedX), coords);
          // find circle center coords (fluent)
          var circleCenterCoords = MU.getCoordsFromDistanceAndAngle(turnedBaseX, turnedBaseY, angle, distance);
          
          // find solid angle (the way the leg is attached to the base)
          let solidAngle = this.calcSolidAngle(side, coxaAttachment, baseDirection);
          // solid (unturned) circle center coords
          var { x: solidX, y: solidY } = MU.getCoordsFromDistanceAndAngle(tbx, tby, solidAngle, distance);
        }
        // turn joystick is centered (x: 0)
        else
          var circleCenterCoords = MU.getCoordsFromDistanceAndAngle(tbx, tby, angle, distance);
          
        return {
          x: circleCenterCoords.x,
          y: circleCenterCoords.y,
          solidX,
          solidY,
          // fluentX,
          // fluentY,
          fluentTransverseBaseX: turnedBaseX,
          fluentTransverseBaseY: turnedBaseY,
          fluentRadius: circleDiameter / 2,
          fluentDiameter: circleDiameter,
          radius: 80,
          diameter: 160
        }
      }
      
      calcAngle(side, coxaAttachment, baseDirection) {
        switch (side) {
          case 'left':
            return coxaAttachment + baseDirection - this.turnJoystick.normalizedX;
          case 'right':
            return MU.flipNumber(coxaAttachment + baseDirection - this.turnJoystick.normalizedX);
        }
      }
      
      calcSolidAngle(side, coxaAttachment, baseDirection) {
        switch (side) {
          case 'left':
            return coxaAttachment + baseDirection;
          case 'right':
            return MU.flipNumber(coxaAttachment + baseDirection);
        }
      }
      
      sieveOutAndGatherUp(legId, circle, payload) {
        // filter in unique values and add them to the payload[legId] object
        GU.sieveOutAndGatherUp(circle, this.circles[legId], payload, legId);
      }
      
      dispatchCirles(payload) {
        // empty payload object
        if (Object.keys(payload).length === 0) return;
        
        store.dispatch({ type: "MOVEMENT_CIRCLES_CHANGED_BATCHED", payload });
      }
      
      observeTurnJoystick(newValue, oldValue) {
        // skip init because circles will be generated in the observeCoords function
        if (oldValue === undefined) return;
        
        var payload = {};
        
        for (let legId = 1; legId <= 6; legId++) {
          let circle = this.processNewCircle(legId, this.misc[legId].transverseReachRadius, this.coords[legId]);
          this.sieveOutAndGatherUp(legId, circle, payload);
        }
        
        this.dispatchCirles(payload);
      }

    }
    window.customElements.define(circleGenerator.is, circleGenerator);
  </script>
</dom-module>