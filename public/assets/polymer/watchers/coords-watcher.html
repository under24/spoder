<link rel="import" href="../../../../../bower_components/polymer/polymer-element.html">

<dom-module id="coords-watcher">
  <script>
    class coordsWatcher extends ReduxMixin(Polymer.Element) {
      static get is() { return 'coords-watcher'; }
      static get properties() {
        return {
          metaData: {
            statePath: 'metaData'
          },
          angles: {
            statePath: 'angles'
          },
          // used for comparison before dispatching
          baseDirection: {
            statePath: 'base.direction'
          },
          // used for comparison before dispatching
          baseCenterCoords: {
            statePath: 'base.centerCoords'
          },
          // used for supplying values to movement circles
          misc: {
            statePath: 'misc'
          },
          baseCoxaAttachmentAngle: {
            statePath: 'base.coxaAttachmentAngle'
          },
          turnJoystick: {
            statePath: 'movement.turnJoystick',
            observer: 'observeTurnJoystick'
          },
          coords: {
            statePath: 'coords',
            observer: 'observeCoords'
          }
        };
      }
      
      // BEGIN HELPER FUNCTIONS
      
      getDistanceFromBaseToCursor(legId, view) {
        return MU.getDistance(this.getDX(legId, view), this.getDY(legId, view));
      }
      
      getDX(legId, view) {
        return this.coords[legId][`${view}CursorX`] - this.coords[legId][`${view}BaseX`];
      }
      
      getDY(legId, view) {
        return this.coords[legId][`${view}CursorY`] - this.coords[legId][`${view}BaseY`];
      }
      
      getReachDistance(legId, view) {
        return this.getDistanceFromBaseToCursor(legId, view) - this.metaData.combinedLegsLength;
      }
      
      targetWithinReach(legId, view) {
        return this.getReachDistance(legId, view) > 0 ? false : true;
      }

      getAngleFromDistance(legId, view) {
        let screen = MU.getAngle(this.getDY(legId, view), this.getDX(legId, view)),
            servo = GU.correctAngle(screen + 90);
        
        return { screen, servo: +servo.toFixed(0) };
      }
      
      sameCoords(newCoords, oldCoords, view, legId) {
        if (newCoords[legId][`${view}CursorX`] !== oldCoords[legId][`${view}CursorX`] ||
            newCoords[legId][`${view}CursorY`] !== oldCoords[legId][`${view}CursorY`] ||
            newCoords[legId][`${view}BaseX`] !== oldCoords[legId][`${view}BaseX`] ||
            newCoords[legId][`${view}BaseY`] !== oldCoords[legId][`${view}BaseY`]) return false;
            
        return true;
      }
      
      // END HELPER FUNCTIONS
      
      // -------------------------------------------------
      
      // BEGIN MISC GATHERING
      
      getSagittalMiscData(legId) {
        let sagittalWithinReach = this.targetWithinReach(legId, 'sagittal');
        
        // sagittal diff x/y
        let dx = this.getDX(legId, 'sagittal'),
            dy = this.getDY(legId, 'sagittal');
        
        // sagittal distance from sagittal cursor x/y to sagittal base x/y
        let distance = MU.getDistance(dx, dy);
        
        // sagittal straight angle from base to cursor
        let angle = MU.getAngle(dy, dx);
        
        // sagittal boundary ball xy
        let sbx = this.coords[legId].sagittalBaseX,
            sby = this.coords[legId].sagittalBaseY,
            sagittalBoundaryBallCoords = MU.getCoordsFromDistanceAndAngle(sbx, sby, angle, this.metaData.combinedLegsLength);
        
        // transverse misc data
        let transverseReachCoords = PU.getTransverseReachCoords(this.coords[legId], this.metaData),
            transverseReachRadius = PU.getTransverseReachRadius(transverseReachCoords),
            transverseLegLength = PU.getTransverseLegLength(sagittalWithinReach, dx, sbx, sagittalBoundaryBallCoords);

        return {
          sagittalDiff: { dx, dy },
          sagittalDistance: distance,
          sagittalAngle: angle,
          sagittalBoundaryBallCoords,
          transverseReachCoords,
          transverseReachRadius,
          transverseLegLength
        };
      }
      
      getTransverseMiscData(legId) {
        // let dx = this.getDX(legId, 'transverse');
        // let dy = this.getDY(legId, 'transverse');
        // let distance = MU.getDistance(dx, dy);
        
        return {
          // transverseDiff: { dx, dy },
          // transverseDistance: distance
        };
      }
      
      getMovementCircleData(legId, transverseReachRadius, coords, baseDirection) {
        let movementCircleDiameter = PU.getMovementCircleDiameter(transverseReachRadius, this.metaData),
            movementCircleRadius = movementCircleDiameter / 2;
            
        let distance = (transverseReachRadius + this.metaData.impossibleRange) / 2,
            tbx = coords.transverseBaseX,
            tby = coords.transverseBaseY,
            coxaAttachment = this.baseCoxaAttachmentAngle[legId],
            angle,
            // guide point
            turnedTBX,
            turnedTBY,
            // unturned movement circle coords
            unturnedX,
            unturnedY,
            // movement circle x/y coords
            movementCircleCenterCoords,
            angleForUnturnedXY;
            
        // sum up baseCoxaAttachmentAngle + movement.directionJoystick + movement.turnJoystick
        switch (GU.getSideFromLegId(legId)) {
          case 'left':
            angle = (coxaAttachment + baseDirection) - this.turnJoystick.x; break;
          case 'right':
            angle = MU.flipNumber(coxaAttachment + baseDirection) + this.turnJoystick.x; break;
        }
        
        // turn base coords if turnJoystick.x !== 0
        if (this.turnJoystick.x) {
          // turn base coords
          ({ x: turnedTBX, y: turnedTBY } = RU.getRotatedCoords(this.baseCenterCoords, MU.flipNumber(this.turnJoystick.x), this.coords[legId]));
          // find movement circle coords
          movementCircleCenterCoords = MU.getCoordsFromDistanceAndAngle(turnedTBX, turnedTBY, angle, distance);
          
          // also find unturned movement circle coords
          switch (GU.getSideFromLegId(legId)) {
            case 'left':
              angleForUnturnedXY = coxaAttachment + baseDirection; break;
            case 'right':
              angleForUnturnedXY = MU.flipNumber(coxaAttachment + baseDirection); break;
          }
          ({ x: unturnedX, y: unturnedY } = MU.getCoordsFromDistanceAndAngle(tbx, tby, angleForUnturnedXY, distance));
        }
        // turnJoystick.x === 0
        else {
          movementCircleCenterCoords = MU.getCoordsFromDistanceAndAngle(tbx, tby, angle, distance);
        }
        
        return {
          x: movementCircleCenterCoords.x,
          y: movementCircleCenterCoords.y,
          unturnedX,
          unturnedY,
          turnedTBXGuidePoint: turnedTBX,
          turnedTBYGuidePoint: turnedTBY,
          fluentRadius: movementCircleRadius,
          fluentDiameter: movementCircleDiameter,
          radius: 80,
          diameter: 160
        }
      }
      
      // END MISC GATHERING
      
      // -------------------------------------------------
      
      // BEGIN POSITIONING LOGIC
      
      processTransverseCoordsIntoCoxaAngles(legId) {
        let coxaAngles = this.getAngleFromDistance(legId, 'transverse');
        
        coxaAngles.servo = this.validateCoxaOffset(legId, coxaAngles.servo);

        return coxaAngles;
      }
      
      processSagittalCoordsIntoFemurAndTibiaAngles(legId) {
        let femuAndTibiaAngles;
        
        if (this.targetWithinReach(legId, 'sagittal'))
          femuAndTibiaAngles = this.calcForWithinReachMode(legId, 'sagittal');
        else
          femuAndTibiaAngles = this.calcForOutOfReachMode(legId, 'sagittal');
        
        return femuAndTibiaAngles;
      }
      
      calcForWithinReachMode(legId, view) {
        let femurAngles = this.getFemurAngle(legId, view),
            tibiaAngles = this.getTibiaAngle(legId, view);
        
        return {
          femurScreenAngle: femurAngles.screen,
          femurServoAngle: femurAngles.servo,
          tibiaScreenAngle: tibiaAngles.screen,
          tibiaServoAngle: tibiaAngles.servo
        }
      }
      
      calcForOutOfReachMode(legId, view) {
        let femurAngles = this.getAngleFromDistance(legId, view);
        
        return {
          femurScreenAngle: femurAngles.screen,
          femurServoAngle: femurAngles.servo,
          tibiaScreenAngle: 0,
          tibiaServoAngle: 0
        }
      }
      
      gatherCoxaAngles(legId, coxaAngles, payload) {
        // check if all the values are the same
        if (this.angles[legId].coxaScreenAngle === coxaAngles.screen &&
            this.angles[legId].coxaServoAngle === coxaAngles.servo) return;
        
        payload[legId] = payload[legId] || {};
        
        if (this.angles[legId].coxaScreenAngle !== coxaAngles.screen)
          payload[legId].coxaScreenAngle = coxaAngles.screen;
          
        if (this.angles[legId].coxaServoAngle !== coxaAngles.servo)
          payload[legId].coxaServoAngle = coxaAngles.servo;
      }
      
      gatherFemurAndTibiaAngles(legId, angles, payload) {
        // check if all the values are the same
        if (this.angles[legId].femurScreenAngle === angles.femurScreenAngle &&
            this.angles[legId].femurServoAngle === angles.femurServoAngle &&
            this.angles[legId].tibiaScreenAngle === angles.tibiaScreenAngle &&
            this.angles[legId].tibiaServoAngle === angles.tibiaServoAngle) return;
        
        payload[legId] = payload[legId] || {};
        
        if (this.angles[legId].femurScreenAngle !== angles.femurScreenAngle)
          payload[legId].femurScreenAngle = angles.femurScreenAngle;
          
        if (this.angles[legId].femurServoAngle !== angles.femurServoAngle)
          payload[legId].femurServoAngle = angles.femurServoAngle;
          
        if (this.angles[legId].tibiaScreenAngle !== angles.tibiaScreenAngle)
          payload[legId].tibiaScreenAngle = angles.tibiaScreenAngle;
          
        if (this.angles[legId].tibiaServoAngle !== angles.tibiaServoAngle)
          payload[legId].tibiaServoAngle = angles.tibiaServoAngle;
      }
      
      gatherMiscValues(legId, misc, payload) {
        payload[legId] = misc;
      }
      
      gatherMovementCircleValues(legId, movementCircle, payload) {
        payload[legId] = movementCircle;
      }
      
      getFemurAngle(legId, view) {
        let D1 = Math.atan2(this.getDY(legId, view), this.getDX(legId, view)),
            D2 = MU.lawOfCos(this.getDistanceFromBaseToCursor(legId, view), this.metaData.femurLength, this.metaData.tibiaLength);

        let A1 = D2 - D1;
        
        let A1Screen = A1 / Math.PI * -180,
            A1Servo = A1Screen + 90;
        
        return { screen: A1Screen, servo: +A1Servo.toFixed(0) };
      }
      
      getTibiaAngle(legId, view) {
        let A2 = MU.lawOfCos(this.metaData.femurLength, this.metaData.tibiaLength, this.getDistanceFromBaseToCursor(legId, view));
        
        let A2Screen = 180 - (A2 / Math.PI * 180),
            A2Servo = A2Screen;
        
        return { screen: A2Screen, servo: +A2Servo.toFixed(0) };
      }
      
      validateCoxaOffset(legId, coxaAngle) {
        // 3 and 4 have 0 offset rotation 
        switch (legId) {
          case 1:
          case 2:
            coxaAngle += 45; break;
          case 5:
          case 6:
            coxaAngle += -45; break;
        }
        
        return GU.correctAngle(coxaAngle);
      }
      
      // END POSITIONING LOGIC
      
      // -------------------------------------------------
      
      // BEGIN PROPERTY OBSERVERS
      
      observeCoords(newCoords, oldCoords) {
        let anglesPayload = {},
            miscPayload = {}, 
            movementCirclesPayload = {};
            
        let baseCenterCoords = RU.getBaseCenter(newCoords),
            baseDirection = this.getBaseDirection(newCoords, baseCenterCoords);
            
        for (let legId = 1; legId <= 6; legId++) {
          // transverse coords => coxa angles
          if (!oldCoords || !this.sameCoords(newCoords, oldCoords, 'transverse', legId)) {
            
            let coxaAngles = this.processTransverseCoordsIntoCoxaAngles(legId);
            this.gatherCoxaAngles(legId, coxaAngles, anglesPayload);
            
            // let miscValue = this.getTransverseMiscData(legId);
          }
          
          // sagittal coords => femur + tibia angles
          if (!oldCoords || !this.sameCoords(newCoords, oldCoords, 'sagittal', legId)) {
            
            let femurAndTibiaAngles = this.processSagittalCoordsIntoFemurAndTibiaAngles(legId);
            this.gatherFemurAndTibiaAngles(legId, femurAndTibiaAngles, anglesPayload);
            
            let miscValue = this.getSagittalMiscData(legId);
            this.gatherMiscValues(legId, miscValue, miscPayload);
            
            let movementCircleValue = this.getMovementCircleData(legId, miscValue.transverseReachRadius, newCoords[legId], baseDirection);
            this.gatherMovementCircleValues(legId, movementCircleValue, movementCirclesPayload);
          }
        }

        // dispatch
        if (Object.keys(anglesPayload).length !== 0) {
          this.sendServoAngleToSpoder(anglesPayload);
          this.dispatchAngles(anglesPayload);
        } 
        this.validateAndDispatchBaseDirection(baseDirection);
        this.validateAndDispatchBaseCenterCoords(baseCenterCoords);
        if (Object.keys(miscPayload).length !== 0) this.dispatchMisc(miscPayload);
        if (Object.keys(movementCirclesPayload).length !== 0) this.dispatchMovementCircles(movementCirclesPayload);
      }
      
      dispatchAngles(payload) {
        store.dispatch({
          type: "ANGLES_CHANGED_BATCHED",
          payload
        });
      }
      
      dispatchMisc(payload) {
        store.dispatch({
          type: "MISC_CHANGED_BATCHED",
          payload
        });
      }
      
      dispatchMovementCircles(payload) {
        store.dispatch({
          type: "MOVEMENT_CIRCLES_CHANGED_BATCHED",
          payload
        })
      }
      
      validateAndDispatchBaseDirection(payload) {
        // dispatch not needed
        if (this.baseDirection !== undefined && payload === this.baseDirection) return;
        
        store.dispatch({
          type: "BASE_DIRECTION_CHANGED",
          payload
        });
      }
      
      validateAndDispatchBaseCenterCoords(payload) {
        // dispatch not needed
        if (this.baseCenterCoords && payload.x === this.baseCenterCoords.x && payload.y === this.baseCenterCoords.y) return;
        
        store.dispatch({
          type: "BASE_CENTER_COORDS_CHANGED",
          payload
        })
      }
      
      getBaseDirection(newCoords, baseCenterCoords) {
        let baseDirection = MU.getAngle(newCoords[3].transverseBaseY - baseCenterCoords.y, newCoords[3].transverseBaseX - baseCenterCoords.x);
        
        return GU.correctAngle(baseDirection);
      }
      
      observeTurnJoystick(newValue, oldValue) {
        if (oldValue === undefined) return;
        
        let movementCirclesPayload = {};
        
        for (let legId = 1; legId <= 6; legId++) {
          let movementCircleValue = this.getMovementCircleData(legId, this.misc[legId].transverseReachRadius, this.coords[legId], this.baseDirection);
          this.gatherMovementCircleValues(legId, movementCircleValue, movementCirclesPayload);
        }
        
        if (Object.keys(movementCirclesPayload).length !== 0) this.dispatchMovementCircles(movementCirclesPayload);
      }
      
      sendServoAngleToSpoder(angles) {
        // obj for storing filtered out servo angles
        let servoAngles = {};
        
        // loop through the payload obj and filter out servo angles
        for (let key in angles) {
          // check if coxa servo angle is present
          if ('coxaServoAngle' in angles[key]) {
            // check if the obj is created
            servoAngles[key] = servoAngles[key] || {};
            // assign a value
            servoAngles[key].coxaServoAngle = angles[key].coxaServoAngle;
          }
          // check if femur servo angle is present
          if ('femurServoAngle' in angles[key]) {
            // check if the obj is created
            servoAngles[key] = servoAngles[key] || {};
            // assign a value
            servoAngles[key].femurServoAngle = angles[key].femurServoAngle;
          }
          // check if tibia servo angle is present
          if ('tibiaServoAngle' in angles[key]) {
            // check if the obj is created
            servoAngles[key] = servoAngles[key] || {};
            // assign a value
            servoAngles[key].tibiaServoAngle = angles[key].tibiaServoAngle;
          }
        }
        
        // if there are some servo angles then send to the back end
        if (Object.keys(servoAngles).length !== 0)
          socket.emit('servo-angles-changed', servoAngles);
        
        // if (angles[1].femurServoAngle)
          // socket.emit('femur-servo-angle-changed', { value: angles[1].femurServoAngle });
      }
      
      // END PROPERTY OBSERVERS

    }
    window.customElements.define(coordsWatcher.is, coordsWatcher);
  </script>
</dom-module>