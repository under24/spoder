<link rel="import" href="coords-watcher/servo-angle-gateway.html">
<link rel="import" href="coords-watcher/base-generator.html">
<link rel="import" href="coords-watcher/misc-generator.html">
<link rel="import" href="coords-watcher/circle-generator.html">

<dom-module id="coords-watcher">
  <template>
    <servo-angle-gateway id="servoGateway"></servo-angle-gateway>
    <base-generator id="baseGenerator"></base-generator>
    <misc-generator id="miscGenerator"></misc-generator>
    <circle-generator id="circleGenerator"></circle-generator>
  </template>
  <script>
    class coordsWatcher extends ReduxMixin(Polymer.Element) {
      static get is() { return 'coords-watcher'; }
      static get properties() {
        return {
          metaData: {
            statePath: 'metaData'
          },
          angles: {
            statePath: 'angles'
          },
          // used for comparison before dispatching
          baseDirection: {
            statePath: 'base.direction'
          },
          // used for comparison before dispatching
          baseCenterCoords: {
            statePath: 'base.centerCoords'
          },
          // used for supplying values to movement circles
          misc: {
            statePath: 'misc'
          },
          baseCoxaAttachmentAngle: {
            statePath: 'base.coxaAttachmentAngle'
          },
          turnJoystick: {
            statePath: 'movement.turnJoystick',
            observer: 'observeTurnJoystick'
          },
          coords: {
            statePath: 'coords',
            observer: 'observeCoords'
          }
        };
      }
      
      // BEGIN HELPER FUNCTIONS
      
      getDistanceFromBaseToCursor(legId, view) {
        return MU.getDistance(this.getDX(legId, view), this.getDY(legId, view));
      }
      
      getDX(legId, view) {
        return this.coords[legId][`${view}CursorX`] - this.coords[legId][`${view}BaseX`];
      }
      
      getDY(legId, view) {
        return this.coords[legId][`${view}CursorY`] - this.coords[legId][`${view}BaseY`];
      }
      
      getReachDistance(legId, view) {
        return this.getDistanceFromBaseToCursor(legId, view) - this.metaData.combinedLegsLength;
      }
      
      targetWithinReach(legId, view) {
        return this.getReachDistance(legId, view) > 0 ? false : true;
      }

      getAngleFromDistance(legId, view) {
        let screen = MU.getAngle(this.getDY(legId, view), this.getDX(legId, view)),
            servo = GU.correctAngle(screen + 90);
        
        return { screen, servo: +servo.toFixed(0) };
      }
      
      sameCoords(newCoords, oldCoords, view, legId) {
        if (newCoords[legId][`${view}CursorX`] !== oldCoords[legId][`${view}CursorX`] ||
            newCoords[legId][`${view}CursorY`] !== oldCoords[legId][`${view}CursorY`] ||
            newCoords[legId][`${view}BaseX`] !== oldCoords[legId][`${view}BaseX`] ||
            newCoords[legId][`${view}BaseY`] !== oldCoords[legId][`${view}BaseY`]) return false;
            
        return true;
      }
      
      // END HELPER FUNCTIONS
      
      // -------------------------------------------------
      
      processNewCircles(legId, transverseReachRadius, coords, baseDirection, baseCenterCoords) {
        let movementCircleDiameter = transverseReachRadius - this.metaData.impossibleRange;
        
        // distance to the center of the circle + offset from impossible range
        let distance = (transverseReachRadius + this.metaData.impossibleRange) / 2,
            tbx = coords.transverseBaseX,
            tby = coords.transverseBaseY,
            coxaAttachment = this.baseCoxaAttachmentAngle[legId];
            
        // sum up baseCoxaAttachmentAngle + movement.directionJoystick + movement.turnJoystick
        switch (GU.getLegSide(legId)) {
          case 'left':
            var angle = (coxaAttachment + baseDirection) - this.turnJoystick.x; break;
          case 'right':
            var angle = MU.flipNumber(coxaAttachment + baseDirection) + this.turnJoystick.x; break;
        }
        
        // turn base coords if turnJoystick.x !== 0
        if (this.turnJoystick.x) {
          // turn base coords
          var { x: turnedTBX, y: turnedTBY } = RU.getRotatedCoords(baseCenterCoords, MU.flipNumber(this.turnJoystick.x), coords, GU.getLegSide(legId));
          // find movement circle coords
          var movementCircleCenterCoords = MU.getCoordsFromDistanceAndAngle(turnedTBX, turnedTBY, angle, distance);
          
          // also find unturned movement circle coords
          switch (GU.getLegSide(legId)) {
            case 'left':
              var angleForUnturnedXY = coxaAttachment + baseDirection; break;
            case 'right':
              var angleForUnturnedXY = MU.flipNumber(coxaAttachment + baseDirection); break;
          }
          // unturned movement circle coords
          var { x: unturnedX, y: unturnedY } = MU.getCoordsFromDistanceAndAngle(tbx, tby, angleForUnturnedXY, distance);
        }
        // turnJoystick.x === 0
        else
          var movementCircleCenterCoords = MU.getCoordsFromDistanceAndAngle(tbx, tby, angle, distance);
          
        return {
          // for when the leg is raised. the circle should have solid position so it does not move when the leg is raised
          // x: MU.getCoordsFromDistanceAndAngle(turnedTBX, turnedTBY, angle, this.metaData.impossibleRange + 80).x,
          // y: MU.getCoordsFromDistanceAndAngle(turnedTBX, turnedTBY, angle, this.metaData.impossibleRange + 80).y,
          x: movementCircleCenterCoords.x,
          y: movementCircleCenterCoords.y,
          // fluentX: movementCircleCenterCoords.x,
          // fluentY: movementCircleCenterCoords.y,
          unturnedX,
          unturnedY,
          turnedTBXGuidePoint: turnedTBX,
          turnedTBYGuidePoint: turnedTBY,
          radius: movementCircleDiameter / 2,
          diameter: movementCircleDiameter,
          // radius: 80,
          // diameter: 160
        }
      }
      
      // -------------------------------------------------
      
      // BEGIN POSITIONING LOGIC
      
      processNewCoxaAngles(legId) {
        let coxaAngles = this.getAngleFromDistance(legId, 'transverse');
        
        // correct the coxa servo angle
        this.correctCoxaOffset(legId, coxaAngles);

        return coxaAngles;
      }
      
      processNewFemurAndTibiaAngles(legId) {
        // within reach
        if (this.targetWithinReach(legId, 'sagittal'))
          var femuAndTibiaAngles = this.calcForWithinReachMode(legId, 'sagittal');
        // out of reach
        else
          var femuAndTibiaAngles = this.calcForOutOfReachMode(legId, 'sagittal');
        
        return femuAndTibiaAngles;
      }
      
      calcForWithinReachMode(legId, view) {
        let femurAngles = this.getFemurAngle(legId, view),
            tibiaAngles = this.getTibiaAngle(legId, view);
        
        return {
          femurScreenAngle: femurAngles.screen,
          femurServoAngle: femurAngles.servo,
          tibiaScreenAngle: tibiaAngles.screen,
          tibiaServoAngle: tibiaAngles.servo
        }
      }
      
      calcForOutOfReachMode(legId, view) {
        let femurAngles = this.getAngleFromDistance(legId, view);
        
        return {
          femurScreenAngle: femurAngles.screen,
          femurServoAngle: femurAngles.servo,
          tibiaScreenAngle: 0,
          tibiaServoAngle: 0
        }
      }
      
      prepareCoxaPayload(legId, coxaAngles, payload) {
        // check if all the values are the same
        if (this.angles[legId].coxaScreenAngle === coxaAngles.screen &&
            this.angles[legId].coxaServoAngle === coxaAngles.servo) return;
        
        payload[legId] = payload[legId] || {};
        
        if (this.angles[legId].coxaScreenAngle !== coxaAngles.screen)
          payload[legId].coxaScreenAngle = coxaAngles.screen;
          
        if (this.angles[legId].coxaServoAngle !== coxaAngles.servo)
          payload[legId].coxaServoAngle = coxaAngles.servo;
      }
      
      // correct servo angle (if outside the possible servo boundaries 0-180deg)
      validateCoxaServoRange(coxaAngles) {
        if (coxaAngles.servo < 0) coxaAngles.servo = 0;
        if (coxaAngles.servo > 180) coxaAngles.servo = 180;
      }
      
      prepareFemurAndTibiaPayload(legId, angles, payload) {
        // check if all the values are the same
        if (this.angles[legId].femurScreenAngle === angles.femurScreenAngle &&
            this.angles[legId].femurServoAngle === angles.femurServoAngle &&
            this.angles[legId].tibiaScreenAngle === angles.tibiaScreenAngle &&
            this.angles[legId].tibiaServoAngle === angles.tibiaServoAngle) return;
        
        payload[legId] = payload[legId] || {};
        
        if (this.angles[legId].femurScreenAngle !== angles.femurScreenAngle)
          payload[legId].femurScreenAngle = angles.femurScreenAngle;
          
        if (this.angles[legId].femurServoAngle !== angles.femurServoAngle)
          payload[legId].femurServoAngle = angles.femurServoAngle;
          
        if (this.angles[legId].tibiaScreenAngle !== angles.tibiaScreenAngle)
          payload[legId].tibiaScreenAngle = angles.tibiaScreenAngle;
          
        if (this.angles[legId].tibiaServoAngle !== angles.tibiaServoAngle)
          payload[legId].tibiaServoAngle = angles.tibiaServoAngle;
      }
      
      // correct servo angle (if outside the possible servo boundaries 0-180deg)
      validateFemurAndTibiaServoRange(angles) {
        // femur
        if (angles.femurServoAngle < 0) angles.femurServoAngle = 0;
        if (angles.femurServoAngle > 180) angles.femurServoAngle = 180;
        
        // tibia
        if (angles.tibiaServoAngle < 0) angles.tibiaServoAngle = 0;
        if (angles.tibiaServoAngle > 180) angles.tibiaServoAngle = 180;
      }
      
      getFemurAngle(legId, view) {
        let D1 = Math.atan2(this.getDY(legId, view), this.getDX(legId, view)),
            D2 = MU.lawOfCos(this.getDistanceFromBaseToCursor(legId, view), this.metaData.femurLength, this.metaData.tibiaLength);

        let A1 = D2 - D1;
        
        let A1Screen = A1 / Math.PI * -180,
            A1Servo = A1Screen + 90;
        
        return { screen: A1Screen, servo: +A1Servo.toFixed(0) };
      }
      
      getTibiaAngle(legId, view) {
        let A2 = MU.lawOfCos(this.metaData.femurLength, this.metaData.tibiaLength, this.getDistanceFromBaseToCursor(legId, view));
        
        let A2Screen = 180 - (A2 / Math.PI * 180),
            A2Servo = A2Screen;
        
        return { screen: A2Screen, servo: +A2Servo.toFixed(0) };
      }
      
      correctCoxaOffset(legId, coxaAngles) {
        // legs 3 and 4 have 0 offset rotation 
        switch (legId) {
          case 1:
          case 2:
            coxaAngles.servo += 45; break;
          case 5:
          case 6:
            coxaAngles.servo += -45; break;
        }
        
        // correct angle if after applying coxa offset the angle is outside 0-360 range
        coxaAngles.servo = GU.correctAngle(coxaAngles.servo);
      }
      
      // END POSITIONING LOGIC
      
      // -------------------------------------------------
      
      // BEGIN PROPERTY OBSERVERS
      
      observeCoords(newCoords, oldCoords) {
        let anglesPayload = {},
            miscPayload = {}, 
            movementCirclesPayload = {};
            
        let baseCenterCoords = this.$.baseGenerator.calcBaseCenterCoords(newCoords),
            baseDirection = this.$.baseGenerator.calcBaseDirection(newCoords, baseCenterCoords);
            
        for (let legId = 1; legId <= 6; legId++) {
          
          // transverse coords
          if (!oldCoords || !this.sameCoords(newCoords, oldCoords, 'transverse', legId)) {
            // transverse coords -> coxa angles
            let coxaAngles = this.processNewCoxaAngles(legId);
            // correct coxa servo angles if outside possible servo boundaries (0-180deg)
            this.validateCoxaServoRange(coxaAngles);
            // prepare payload obj by filtering out state diplicate values before dispatching
            this.prepareCoxaPayload(legId, coxaAngles, anglesPayload);
          }
          
          // sagittal coords
          if (!oldCoords || !this.sameCoords(newCoords, oldCoords, 'sagittal', legId)) {
            // sagittal coords -> femur + tibia angles
            let femurAndTibiaAngles = this.processNewFemurAndTibiaAngles(legId);
            // correct femur and tibia servo angles if outside possible servo boundaries (0-180deg)
            this.validateFemurAndTibiaServoRange(femurAndTibiaAngles);
            // prepare payload obj by filtering out state diplicate values before dispatching
            this.prepareFemurAndTibiaPayload(legId, femurAndTibiaAngles, anglesPayload);
            
            // misc
            let miscValue = this.$.miscGenerator.processNewMisc(this, legId);
            this.$.miscGenerator.gatherMiscValues(legId, miscValue, miscPayload);
            
            // movement circles
            let movementCircleValue = this.processNewCircles(legId, miscValue.transverseReachRadius, newCoords[legId], baseDirection, baseCenterCoords);
            this.$.circleGenerator.gatherMovementCircleValues(legId, movementCircleValue, movementCirclesPayload);
          }
        }

        // dispatch
        this.validateAndDispatchAngle(anglesPayload);
        this.$.baseGenerator.validateAndDispatchBaseDirection(baseDirection);
        this.$.baseGenerator.validateAndDispatchBaseCenterCoords(baseCenterCoords);
        this.$.miscGenerator.validateAndDispatchMisc(miscPayload);
        this.$.circleGenerator.validateAndDispatchMovementCircles(movementCirclesPayload);
      }
      
      validateAndDispatchAngle(payload) {
        // empty payload object
        if (Object.keys(payload).length === 0) return;

        // send the angles to the back end
        this.$.servoGateway.emitAngles(payload);
        
        // dispatch is safe because the values were filtered out in this.prepareFemurAndTibiaPayload and this.prepareCoxaPayload
        store.dispatch({ type: "ANGLES_CHANGED_BATCHED", payload });
      }
      
      observeTurnJoystick(newValue, oldValue) {
        // skip init because circles will be generated in the observeCoords function
        if (oldValue === undefined) return;
        
        let movementCirclesPayload = {};
        
        for (let legId = 1; legId <= 6; legId++) {
          let movementCircleValue = this.processNewCircles(legId, this.misc[legId].transverseReachRadius, this.coords[legId], this.baseDirection, this.baseCenterCoords);
          this.$.circleGenerator.gatherMovementCircleValues(legId, movementCircleValue, movementCirclesPayload);
        }
        
        this.$.circleGenerator.validateAndDispatchMovementCircles(movementCirclesPayload);
      }
      
      // END PROPERTY OBSERVERS

    }
    window.customElements.define(coordsWatcher.is, coordsWatcher);
  </script>
</dom-module>