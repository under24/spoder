<link rel="import" href="coords-watcher/servo-angle-gateway.html">
<link rel="import" href="coords-watcher/base-generator.html">
<link rel="import" href="coords-watcher/misc-generator.html">
<link rel="import" href="coords-watcher/circle-generator.html">

<dom-module id="coords-watcher">
  <template>
    <servo-angle-gateway id="servoGateway"></servo-angle-gateway>
    <base-generator id="baseGenerator"></base-generator>
    <misc-generator id="miscGenerator"></misc-generator>
    <circle-generator id="circleGenerator"></circle-generator>
  </template>
  <script>
    class coordsWatcher extends ReduxMixin(Polymer.Element) {
      static get is() { return 'coords-watcher'; }
      static get properties() {
        return {
          metaData: {
            statePath: 'metaData'
          },
          angles: {
            statePath: 'angles'
          },
          coords: {
            statePath: 'coords',
            observer: 'observeCoords'
          }
        };
      }
      
      getDistanceFromBaseToCursor(legId, view) {
        return MU.getDistance(this.getDX(legId, view), this.getDY(legId, view));
      }
      
      getDX(legId, view) {
        return this.coords[legId][`${view}CursorX`] - this.coords[legId][`${view}BaseX`];
      }
      
      getDY(legId, view) {
        return this.coords[legId][`${view}CursorY`] - this.coords[legId][`${view}BaseY`];
      }
      
      getReachDistance(legId, view) {
        return this.getDistanceFromBaseToCursor(legId, view) - this.metaData.combinedLegsLength;
      }
      
      targetWithinReach(legId, view) {
        return this.getReachDistance(legId, view) > 0 ? false : true;
      }

      getAngleFromDistance(legId, view) {
        let screen = MU.getAngle(this.getDY(legId, view), this.getDX(legId, view)),
            servo = GU.correctAngle(screen + 90);
        
        return { screen, servo: +servo.toFixed(0) };
      }
      
      sameCoords(newCoords, oldCoords, view, legId) {
        if (newCoords[legId][`${view}CursorX`] !== oldCoords[legId][`${view}CursorX`] ||
            newCoords[legId][`${view}CursorY`] !== oldCoords[legId][`${view}CursorY`] ||
            newCoords[legId][`${view}BaseX`] !== oldCoords[legId][`${view}BaseX`] ||
            newCoords[legId][`${view}BaseY`] !== oldCoords[legId][`${view}BaseY`]) return false;
            
        return true;
      }
      
      processNewCoxaAngles(legId) {
        let coxaAngles = this.getAngleFromDistance(legId, 'transverse');
        
        // correct the coxa servo angle
        this.correctCoxaOffset(legId, coxaAngles);

        return coxaAngles;
      }
      
      processNewFemurAndTibiaAngles(legId) {
        // within reach
        if (this.targetWithinReach(legId, 'sagittal'))
          var femuAndTibiaAngles = this.calcForWithinReachMode(legId, 'sagittal');
        // out of reach
        else
          var femuAndTibiaAngles = this.calcForOutOfReachMode(legId, 'sagittal');
        
        return femuAndTibiaAngles;
      }
      
      calcForWithinReachMode(legId, view) {
        let femurAngles = this.getFemurAngle(legId, view),
            tibiaAngles = this.getTibiaAngle(legId, view);
        
        return {
          femurScreenAngle: femurAngles.screen,
          femurServoAngle: femurAngles.servo,
          tibiaScreenAngle: tibiaAngles.screen,
          tibiaServoAngle: tibiaAngles.servo
        }
      }
      
      calcForOutOfReachMode(legId, view) {
        let femurAngles = this.getAngleFromDistance(legId, view);
        
        return {
          femurScreenAngle: femurAngles.screen,
          femurServoAngle: femurAngles.servo,
          tibiaScreenAngle: 0,
          tibiaServoAngle: 0
        }
      }
      
      prepareCoxaPayload(legId, coxaAngles, payload) {
        // check if all the values are the same
        if (this.angles[legId].coxaScreenAngle === coxaAngles.screen &&
            this.angles[legId].coxaServoAngle === coxaAngles.servo) return;
        
        payload[legId] = payload[legId] || {};
        
        if (this.angles[legId].coxaScreenAngle !== coxaAngles.screen)
          payload[legId].coxaScreenAngle = coxaAngles.screen;
          
        if (this.angles[legId].coxaServoAngle !== coxaAngles.servo)
          payload[legId].coxaServoAngle = coxaAngles.servo;
      }
      
      // correct servo angle (if outside the possible servo boundaries 0-180deg)
      validateCoxaServoRange(coxaAngles) {
        if (coxaAngles.servo < 0) coxaAngles.servo = 0;
        if (coxaAngles.servo > 180) coxaAngles.servo = 180;
      }
      
      prepareFemurAndTibiaPayload(legId, angles, payload) {
        // check if all the values are the same
        if (this.angles[legId].femurScreenAngle === angles.femurScreenAngle &&
            this.angles[legId].femurServoAngle === angles.femurServoAngle &&
            this.angles[legId].tibiaScreenAngle === angles.tibiaScreenAngle &&
            this.angles[legId].tibiaServoAngle === angles.tibiaServoAngle) return;
        
        payload[legId] = payload[legId] || {};
        
        if (this.angles[legId].femurScreenAngle !== angles.femurScreenAngle)
          payload[legId].femurScreenAngle = angles.femurScreenAngle;
          
        if (this.angles[legId].femurServoAngle !== angles.femurServoAngle)
          payload[legId].femurServoAngle = angles.femurServoAngle;
          
        if (this.angles[legId].tibiaScreenAngle !== angles.tibiaScreenAngle)
          payload[legId].tibiaScreenAngle = angles.tibiaScreenAngle;
          
        if (this.angles[legId].tibiaServoAngle !== angles.tibiaServoAngle)
          payload[legId].tibiaServoAngle = angles.tibiaServoAngle;
      }
      
      // correct servo angle (if outside the possible servo boundaries 0-180deg)
      validateFemurAndTibiaServoRange(angles) {
        // femur
        if (angles.femurServoAngle < 0) angles.femurServoAngle = 0;
        if (angles.femurServoAngle > 180) angles.femurServoAngle = 180;
        
        // tibia
        if (angles.tibiaServoAngle < 0) angles.tibiaServoAngle = 0;
        if (angles.tibiaServoAngle > 180) angles.tibiaServoAngle = 180;
      }
      
      getFemurAngle(legId, view) {
        let D1 = Math.atan2(this.getDY(legId, view), this.getDX(legId, view)),
            D2 = MU.lawOfCos(this.getDistanceFromBaseToCursor(legId, view), this.metaData.femurLength, this.metaData.tibiaLength);

        let A1 = D2 - D1;
        
        let A1Screen = A1 / Math.PI * -180,
            A1Servo = A1Screen + 90;
        
        return { screen: A1Screen, servo: +A1Servo.toFixed(0) };
      }
      
      getTibiaAngle(legId, view) {
        let A2 = MU.lawOfCos(this.metaData.femurLength, this.metaData.tibiaLength, this.getDistanceFromBaseToCursor(legId, view));
        
        let A2Screen = 180 - (A2 / Math.PI * 180),
            A2Servo = A2Screen;
        
        return { screen: A2Screen, servo: +A2Servo.toFixed(0) };
      }
      
      correctCoxaOffset(legId, coxaAngles) {
        // legs 3 and 4 have 0 offset rotation 
        switch (legId) {
          case 1:
          case 2:
            coxaAngles.servo += 45; break;
          case 5:
          case 6:
            coxaAngles.servo += -45; break;
        }
        
        // correct angle if after applying coxa offset the angle is outside 0-360 range
        coxaAngles.servo = GU.correctAngle(coxaAngles.servo);
      }
      
      observeCoords(newCoords, oldCoords) {
        let anglesPayload = {},
            miscPayload = {}, 
            circlesPayload = {};
            
        let baseCenterCoords = this.$.baseGenerator.calcBaseCenterCoords(newCoords),
            baseDirection = this.$.baseGenerator.calcBaseDirection(newCoords, baseCenterCoords);
            
        for (let legId = 1; legId <= 6; legId++) {
          
          // transverse coords
          if (!oldCoords || !this.sameCoords(newCoords, oldCoords, 'transverse', legId)) {
            // transverse coords -> coxa angles
            let coxaAngles = this.processNewCoxaAngles(legId);
            // correct coxa servo angles if outside possible servo boundaries (0-180deg)
            this.validateCoxaServoRange(coxaAngles);
            // prepare payload obj by filtering out state diplicate values before dispatching
            this.prepareCoxaPayload(legId, coxaAngles, anglesPayload);
          }
          
          // sagittal coords
          if (!oldCoords || !this.sameCoords(newCoords, oldCoords, 'sagittal', legId)) {
            // sagittal coords -> femur + tibia angles
            let femurAndTibiaAngles = this.processNewFemurAndTibiaAngles(legId);
            // correct femur and tibia servo angles if outside possible servo boundaries (0-180deg)
            this.validateFemurAndTibiaServoRange(femurAndTibiaAngles);
            // prepare payload obj by filtering out state diplicate values before dispatching
            this.prepareFemurAndTibiaPayload(legId, femurAndTibiaAngles, anglesPayload);
            
            // misc
            let miscValue = this.$.miscGenerator.processNewMisc(this, legId);
            this.$.miscGenerator.gatherMisc(legId, miscValue, miscPayload);
            
            // movement circles
            let circle = this.$.circleGenerator.processNewCircle(legId, miscValue.transverseReachRadius, newCoords[legId], baseDirection, baseCenterCoords);
            this.$.circleGenerator.gatherCircles(legId, circle, circlesPayload);
          }
        }

        // dispatch
        this.validateAndDispatchAngle(anglesPayload);
        this.$.baseGenerator.validateAndDispatchBaseDirection(baseDirection);
        this.$.baseGenerator.validateAndDispatchBaseCenterCoords(baseCenterCoords);
        this.$.miscGenerator.validateAndDispatchMisc(miscPayload);
        this.$.circleGenerator.validateAndDispatchMovementCircles(circlesPayload);
      }
      
      validateAndDispatchAngle(payload) {
        // empty payload object
        if (Object.keys(payload).length === 0) return;

        // send the angles to the back end
        this.$.servoGateway.emitAngles(payload);
        
        // dispatch is safe because the values were filtered out in this.prepareFemurAndTibiaPayload and this.prepareCoxaPayload
        store.dispatch({ type: "ANGLES_CHANGED_BATCHED", payload });
      }

    }
    window.customElements.define(coordsWatcher.is, coordsWatcher);
  </script>
</dom-module>