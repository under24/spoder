<link rel="import" href="../../../../../bower_components/polymer/polymer-element.html">

<dom-module id="pointer-generator">
  <script>
    class pointerGenerator extends ReduxMixin(Polymer.Element) {
      static get is() { return 'pointer-generator'; }
      static get properties() {
        return {
          // validate with the current pointers before dispatching
          pointers: {
            statePath: 'movement.pointers'
          },
          // respect current base direction when calculating pointers
          baseDirection: {
            statePath: 'base.direction'
          },
          // flag which allows rotation when moving in one direction
          applyDirectionAndTurnAngles: {
            statePath: 'movement.settings.applyDirectionAndTurnAngles'
          },
          directionJoystick: {
            statePath: 'movement.directionJoystick'
          },
          circles: {
            statePath: 'movement.circles'
          },
          turnJoystick: {
            statePath: 'movement.turnJoystick'
          }
        }
      }
      
      // calc pointers whenever this.circles || directionJoystick || this.turnJoystick || applyDirectionAndTurnAngles changes
      static get observers() {
        return [ 'processNewPointers(circles, directionJoystick, turnJoystick, applyDirectionAndTurnAngles)' ];
      }
      
      processNewPointers(circles, directionJoystick, turnJoystick, applyDirectionAndTurnAngles) {
        // create new pointers
        var pointers = this.generatePointers(circles, directionJoystick, turnJoystick, applyDirectionAndTurnAngles);
        // dispatch pointers
        this.dispatchPointers(pointers);
      }
      
      generatePointers(circles, directionJoystick, turnJoystick, applyDirectionAndTurnAngles) {
        var pointers = {};
        
        for (let legId = 1; legId <= 6; legId++) {
          let pointer = {};
          
          switch (GU.getLegSide(legId)) {
            case 'left':
              pointer.x = circles[legId].x - circles[legId].radius * (directionJoystick.x / 100); break;
            case 'right':
              pointer.x = circles[legId].x + circles[legId].radius * (directionJoystick.x / 100); break;
          }
          pointer.y = circles[legId].y - circles[legId].radius * (directionJoystick.y / 100);
          
          if (applyDirectionAndTurnAngles)
            // apply baseDirection + turnJoystick
            pointer = this.applyDirectionAndTurn(pointer, circles[legId], this.baseDirection, turnJoystick.x, legId);
          
          // filter in unique value for dispatching
          GU.sieveOutAndGatherUp(pointer, this.pointers[legId], pointers, legId);
        }
        
        return pointers;
      }
      
      applyDirectionAndTurn(pointer, circle, baseDirection, turn, legId) {
        let dx = pointer.x - circle.x,
            dy = pointer.y - circle.y,
            distance = MU.getDistance(dx, dy),
            circleToPointerAngle = MU.getAngle(dy, dx);
            
        // angle correction
        circleToPointerAngle = GU.correctAngle(circleToPointerAngle);
        
        switch (GU.getLegSide(legId)) {
          case 'left':
            return MU.getCoordsFromDistanceAndAngle(circle.x, circle.y, circleToPointerAngle + baseDirection - turn, distance);
          case 'right':
            return MU.getCoordsFromDistanceAndAngle(circle.x, circle.y, circleToPointerAngle - baseDirection + turn, distance);
        }
      }
      
      dispatchPointers(payload) {
        // prevent dispatching an empty payload object
        if (Object.keys(payload).length === 0) return;
        
        store.dispatch({ type: "MOVEMENT_POINTERS_CHANGED_BATCHED", payload });      
      }

    }
    window.customElements.define(pointerGenerator.is, pointerGenerator);
  </script>
</dom-module>