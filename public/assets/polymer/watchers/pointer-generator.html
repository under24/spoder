<link rel="import" href="../../../../../bower_components/polymer/polymer-element.html">

<dom-module id="pointer-generator">
  <script>
    class pointerGenerator extends ReduxMixin(Polymer.Element) {
      static get is() { return 'pointer-generator'; }
      static get properties() {
        return {
          // validate with the current pointers before dispatching
          pointers: {
            statePath: 'movement.pointers'
          },
          // respect current base direction when calculating pointers
          baseDirection: {
            statePath: 'base.direction'
          },
          // flag which allows rotation when moving in one direction
          applyDirectionAndTurnAngles: {
            statePath: 'movement.settings.applyDirectionAndTurnAngles'
          },
          directionJoystick: {
            statePath: 'movement.directionJoystick'
          },
          circles: {
            statePath: 'movement.circles'
          },
          turnJoystick: {
            statePath: 'movement.turnJoystick'
          }
        }
      }
      
      // calc pointers whenever this.circles || directionJoystick || this.turnJoystick || applyDirectionAndTurnAngles changes
      static get observers() {
        return [ 'processNewPointers(circles, directionJoystick, turnJoystick, applyDirectionAndTurnAngles)' ];
      }
      
      processNewPointers(circles, directionJoystick, turnJoystick, applyDirectionAndTurnAngles) {
        // create new pointers
        var pointers = this.generatePointers(circles, directionJoystick, turnJoystick, applyDirectionAndTurnAngles);
        // dispatch pointers
        this.dispatchPointers(pointers);
      }
      
      generatePointers(circles, directionJoystick, turnJoystick, applyDirectionAndTurnAngles) {
        var pointers = {};
        
        for (let legId = 1; legId <= 6; legId++) {
          let currentPointer = {};
          
          switch (GU.getSideFromLegId(legId)) {
            case 'left':
              currentPointer.x = circles[legId].x - circles[legId].radius * (directionJoystick.x / 100); break;
            case 'right':
              currentPointer.x = circles[legId].x + circles[legId].radius * (directionJoystick.x / 100); break;
          }
          currentPointer.y = circles[legId].y - circles[legId].radius * (directionJoystick.y / 100);
          
          if (applyDirectionAndTurnAngles)
            // apply baseDirection + turnJoystick
            currentPointer = this.applyDirectionAndTurn(currentPointer, circles[legId], this.baseDirection, turnJoystick.x, legId);
          
          // check for the same values before dispatching
          this.sieveOutAndGatherUp(currentPointer, this.pointers, legId, pointers);
        }
        
        return pointers;
      }
      
      applyDirectionAndTurn(pointer, circle, baseDirection, turn, legId) {
        let dx = pointer.x - circle.x,
            dy = pointer.y - circle.y,
            distance = MU.getDistance(dx, dy),
            circleToPointerAngle = MU.getAngle(dy, dx);
            
        // angle correction
        circleToPointerAngle = GU.correctAngle(circleToPointerAngle);
        
        switch (GU.getSideFromLegId(legId)) {
          case 'left':
            return MU.getCoordsFromDistanceAndAngle(circle.x, circle.y, circleToPointerAngle + baseDirection - turn, distance);
          case 'right':
            return MU.getCoordsFromDistanceAndAngle(circle.x, circle.y, circleToPointerAngle - baseDirection + turn, distance);
        }
      }
      
      sieveOutAndGatherUp(currentPointer, statePointers, legId, result) {
        // init state
        if (statePointers[legId] === null) {
          result[legId] = currentPointer;
          return;
        }
        
        // check if all the values are the same
        if (currentPointer.x === statePointers[legId].x &&
            currentPointer.y === statePointers[legId].y) return;

        // if not then add them to the result obj
        result[legId] = result[legId] || {};
        
        if (statePointers[legId].x !== currentPointer.x) result[legId].x = currentPointer.x;
        if (statePointers[legId].y !== currentPointer.y) result[legId].y = currentPointer.y;
      }
      
      dispatchPointers(payload) {
        // prevent dispatching an empty payload object
        if (Object.keys(payload).length === 0) return;
        
        store.dispatch({ type: "MOVEMENT_POINTERS_CHANGED_BATCHED", payload });      
      }

    }
    window.customElements.define(pointerGenerator.is, pointerGenerator);
  </script>
</dom-module>