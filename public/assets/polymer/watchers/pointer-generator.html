<dom-module id="pointer-generator">
  <script>
    class pointerGenerator extends ReduxMixin(Polymer.Element) {
      static get is() { return 'pointer-generator'; }
      static get properties() {
        return {
          // validate with the current pointers before dispatching
          pointers: {
            statePath: 'movement.pointers'
          },
          // respect current base direction when calculating pointers
          baseDirection: {
            statePath: 'base.direction'
          },
          // flag which allows rotation when moving in one direction
          applyDirectionAndTurnAngles: {
            statePath: 'movement.settings.applyDirectionAndTurnAngles'
          },
          directionJoystick: {
            statePath: 'movement.directionJoystick'
          },
          circles: {
            statePath: 'movement.circles'
          },
          turnJoystick: {
            statePath: 'movement.turnJoystick'
          }
        }
      }
      
      // calc pointers whenever this.circles || directionJoystick || this.turnJoystick || applyDirectionAndTurnAngles changes
      static get observers() {
        return [ 'processNewPointers(circles, directionJoystick, turnJoystick, applyDirectionAndTurnAngles)' ];
      }
      
      processNewPointers(circles, directionJoystick, turnJoystick, applyDirectionAndTurnAngles) {
        // create new pointers
        var pointers = this.generatePointers(circles, directionJoystick, turnJoystick, applyDirectionAndTurnAngles);
        // dispatch them
        this.dispatchPointers(pointers);
      }
      
      generatePointers(circles, directionJoystick, turnJoystick, applyDirectionAndTurnAngles) {
        var pointers = {};
        
        for (let legId = 1; legId <= 6; legId++) {
          
          let pointer = {
            x: circles[legId].fluentX - circles[legId].solidRadius * (directionJoystick.x / 100),
            y: circles[legId].fluentY - circles[legId].solidRadius * (directionJoystick.y / 100)
          };
          
          if (applyDirectionAndTurnAngles)
            // apply baseDirection + turnJoystick
            pointer = this.applyDirectionAndTurn(pointer, circles[legId], this.baseDirection, turnJoystick.normalizedX);
          
          // filter-in unique value before dispatching
          GU.sieveOutAndGatherUp(pointer, this.pointers[legId], pointers, legId);
        }
        
        return pointers;
      }
      
      applyDirectionAndTurn(pointer, circle, baseDirection, turn) {
        var dx = pointer.x - circle.fluentX,
            dy = pointer.y - circle.fluentY,
            distance = MU.getDistance(dx, dy),
            circleToPointerAngle = MU.getAngle(dy, dx);
            
        // angle correction
        circleToPointerAngle = GU.correctAngle(circleToPointerAngle);
        
        return MU.getCoordsFromDistanceAndAngle(circle.fluentX, circle.fluentY, circleToPointerAngle + baseDirection - turn, distance);
      }
      
      dispatchPointers(payload) {
        // prevent dispatching an empty payload object
        if (Object.keys(payload).length === 0) return;
        
        store.dispatch({ type: "MOVEMENT_POINTERS_CHANGED_BATCHED", payload });      
      }

    }
    window.customElements.define(pointerGenerator.is, pointerGenerator);
  </script>
</dom-module>