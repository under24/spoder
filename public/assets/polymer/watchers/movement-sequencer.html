<link rel="import" href="../../../../../bower_components/polymer/polymer-element.html">

<dom-module id="movement-sequencer">
  <script>
    class movementSequencer extends ReduxMixin(Polymer.Element) {
      static get is() { return 'movement-sequencer'; }
      static get properties() {
        return {
          enabled: {
            statePath: 'movement.settings.generatorEnabled',
            observer: 'observeEnabled'
          },
          iteration: {
            statePath: 'movement.iteration'
          },
          timeline: {
            statePath: 'movement.sequence.timeline'
          },
          loop: {
            statePath: 'movement.settings.loop'
          }
        }
      }
      
      runSequencer(tick = 1) {
        // prevent multiple invocation
        if (this.sequencerInterval) {
          console.warn('Movement sequencer is already in progress');
          return;
        }
        
        // validation
        if (tick > this.iteration.amountOfTicks) {
          console.warn('Specified tick is greater that the amount of ticks in the iteration');
          return;
        }
        
        // iteration starts after (1000 / this.iteration.tps) amount of time with tick 1
        this.sequencerInterval = setInterval(() => {
          
          // dispatch tick data
          store.dispatch({
            type: "SEQUENCE_SHIFTED_XY_BATCHED",
            payload: this.timeline[tick].payload,
            currentTick: tick,
            currentTickPct: this.timeline[tick].pct
          });
          
          // check if that was the last tick
          if (tick === this.iteration.amountOfTicks) {
            // finish current iteration
            this.pauseOrStopSequencer();
            
            // reset progress when the iteration is complete
            store.dispatch({
              type: "MOVEMENT_ITERATION_VALUES_CHANGED",
              payload: { currentTick: 0, currentTickPct: 0 }
            });
            
            // start iterating over again
            if (this.loop)
              this.runSequencer();
            // set generatorEnabled to false (disable movement sequencer)
            else
              store.dispatch({
                type: "MOVEMENT_SETTINGS_CHANGED",
                payload: { generatorEnabled: false }
              });
          }
          
          // update tick value for the next tick interval
          tick++;
          
        }, 1000 / this.iteration.tps);
        
      }
      
      // clear sequencer interval
      pauseOrStopSequencer() {
        clearInterval(this.sequencerInterval);
        this.sequencerInterval = undefined;
      }
      
      runOrResumeSequencer() {
        this.runSequencer(this.iteration.currentTick + 1);
      }
      
      observeEnabled(newValue, oldValue) {
        // movement enabled
        if (newValue === true)
          this.runOrResumeSequencer();
        // movement disabled
        else
          this.pauseOrStopSequencer();
      }

    }
    window.customElements.define(movementSequencer.is, movementSequencer);
  </script>
</dom-module>