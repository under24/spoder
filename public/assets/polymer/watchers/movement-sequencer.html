<link rel="import" href="movement-sequencer/timeline-generator.html">

<dom-module id="movement-sequencer">
  <template>
    <timeline-generator timeline="{{timeline}}"></timeline-generator>
  </template>
  <script>
    class movementSequencer extends ReduxMixin(Polymer.Element) {
      static get is() { return 'movement-sequencer'; }
      static get properties() {
        return {
          enabled: {
            statePath: 'movement.settings.generatorEnabled',
            observer: 'observeEnabled'
          },
          blueprint: {
            statePath: 'movement.iteration.blueprint',
            observer: 'observeBlueprint'
          },
          iteration: {
            statePath: 'movement.iteration'
          },
          loop: {
            statePath: 'movement.settings.loop'
          },
          timeline: Object
        }
      }
      
      runSequencer(currentTick = 1) {
        // validation: no second invocation, no invalid tick, no empty blueprint
        if (!this.validConditions(currentTick)) return;
        
        // iteration starts after (1000 / this.iteration.tps) amount of time with tick 1
        this.sequencerInterval = setInterval(() => {
          // dispatch timeline[currentTick] data
          this.dispatchTickPayload(currentTick);          
          
          // check if that was the last tick of the iteration
          if (currentTick === this.iteration.amountOfTicks) {
            // finish current iteration
            this.pauseSequencer();
            // reset progress when the iteration is complete
            this.resetTickData();
            
            // start iterating over again
            if (this.loop) this.runSequencer();
            // set generatorEnabled to false (disable movement sequencer)
            else this.disableSequencer();
          }
          
          // update tick value for the next tick interval
          currentTick++;
        }, 1000 / this.iteration.tps);
      }
      
      validConditions(currentTick) {
        // double invocation
        if (this.sequencerInterval) {
          console.warn('Movement sequencer is already in progress');
          // fail condition
          return false;
        }
        
        // wrong input tick
        if (currentTick > this.iteration.amountOfTicks) {
          console.warn('Current tick is greater that the amount of ticks in the iteration');
          return false;
        }
        
        // sequencer is idle
        if (this.blueprintEmpty()) {
          if (!this.sequencerIdle) this.sequencerIdle = true;
          // fail condition
          return false;
        }
        
        // valid conditions
        // reset idle flag
        if (this.sequencerIdle) this.sequencerIdle = false;
        // run sequencer
        return true;
      }
      
      blueprintEmpty() {
        // iterate blueprint legs and check if every leg is empty
        for (let key in this.iteration.blueprint) {
          // if a leg has some data then the blueprint is not empty
          if (this.iteration.blueprint[key].length !== 0) return false;
        }
        
        // every blueprint leg is empty
        return true;
      }
      
      dispatchTickPayload(currentTick) {
        // payload is not empty
        if (this.timeline[currentTick].payload)
          store.dispatch({
            type: "SEQUENCE_SHIFTED_XY_BATCHED",
            payload: this.timeline[currentTick].payload,
            currentTick,
            currentTickPct: this.timeline[currentTick].pct
          });
        // payload is empty, dispatch only currentTick and currentTickPct
        // payload can be empty when the current leg/stroke does not have any pexels to move
        else
          store.dispatch({
            type: "MOVEMENT_ITERATION_VALUES_CHANGED",
            payload: {
              currentTick,
              currentTickPct: this.timeline[currentTick].pct 
            }
          });
      }
      
      resetTickData() {
        store.dispatch({
          type: "MOVEMENT_ITERATION_VALUES_CHANGED",
          payload: { currentTick: 0, currentTickPct: 0 }
        });
      }
      
      disableSequencer() {
        store.dispatch({
          type: "MOVEMENT_SETTINGS_CHANGED",
          payload: { generatorEnabled: false }
        });
      }
      
      // clear sequencer interval
      pauseSequencer() {
        clearInterval(this.sequencerInterval);
        this.sequencerInterval = undefined;
      }
      
      observeEnabled(newValue, oldValue) {
        // start sequencer
        if (newValue === true)
          this.runSequencer(this.iteration.currentTick + 1);
        // pause sequencer
        else
          this.pauseSequencer();
      }
      
      observeBlueprint() {
        // if the sequencer is idle then try to run the sequencer again to check if we have some leg data to move
        if (this.sequencerIdle) this.runSequencer();
      }

    }
    window.customElements.define(movementSequencer.is, movementSequencer);
  </script>
</dom-module>