<link rel="import" href="movement-sequencer/timeline-generator.html">

<dom-module id="movement-sequencer">
  <template>
    <timeline-generator timeline="{{timeline}}"></timeline-generator>
  </template>
  <script>
    class movementSequencer extends ReduxMixin(Polymer.Element) {
      static get is() { return 'movement-sequencer'; }
      static get properties() {
        return {
          sequencerEnabled: {
            statePath: 'movement.settings.sequencerEnabled',
            observer: 'observeSequencerEnabled'
          },
          blueprint: {
            statePath: 'movement.iteration.blueprint'
          },
          iteration: {
            statePath: 'movement.iteration.properties'
          },
          loop: {
            statePath: 'movement.settings.loop'
          },
          turnJoystick: {
            statePath: 'movement.turnJoystick'
          },
          coords: {
            statePath: 'coords'
          },
          baseCenterCoords: {
            statePath: 'base.centerCoords'
          },
          timeline: {
            observer: 'observeTimeline'
          }
        }
      }
      
      runSequence(currentTick = 1) {
        // validation: no second invocation, no invalid tick, no idle timeline
        if (!this.validConditions(currentTick)) return;
        
        // iteration starts after (1000 / this.iteration.tps) amount of time with tick 1
        this.sequencerInterval = setInterval(() => {
          // prepare payload data
          var payload = this.addTurningValues(this.timeline[currentTick].payload);
          // dispatch current tick data
          this.dispatchTickPayload(payload, currentTick, this.timeline[currentTick].pct);
          
          // check if that was the last tick of the iteration
          if (currentTick === this.iteration.amountOfTicks) {
            // current iteration is compelete. stop sequencer
            this.clearSequencerInterval();
            // reset progress when the iteration is complete
            this.resetTickData();
            
            // if loop flag is true
            if (this.loop)
              // start iterating over again
              this.runSequence();
            // loop flag is false
            else
              // set sequencerEnabled flag to false which will clear sequencer interval
              this.disableSequencer();
          }
          
          // update tick value for the next tick interval
          currentTick++;
        }, 1000 / this.iteration.tps);
      }
      
      validConditions(currentTick) {
        // double invocation
        if (this.sequencerInterval) {
          console.warn('Movement sequencer is already in progress');
          // fail condition
          return false;
        }
        
        // wrong input tick
        if (currentTick > this.iteration.amountOfTicks) {
          console.warn('Current tick is greater that the amount of ticks in the iteration');
          // fail condition
          return false;
        }
        
        // timeline is idle
        if (this.sequencerIdle)
          // fail condition
          return false;
        
        // valid conditions
        // run sequencer
        return true;
      }
      
      addTurningValues(payload) {
        // no turn values. return back the payload unchanged
        if (this.turnJoystick.normalizedX === 0) return payload;
        
        // calc turn values and add them to the payload
        for (let legId = 1; legId <= 6; legId++) {
          
          // angle / amount of ticks = angle for each tick
          let stepAngle = MU.flipNumber(this.turnJoystick.normalizedX) / this.iteration.amountOfTicks;
        
          // find rotated base coords
          let rotatedCoords = { x: this.coords[legId].transverseBaseX, y: this.coords[legId].transverseBaseY };
          rotatedCoords = MU.rotateCoords(this.baseCenterCoords, rotatedCoords, stepAngle);
        
          // get turn shift values
          let shiftX = this.coords[legId].transverseBaseX - rotatedCoords.x,
              shiftY = this.coords[legId].transverseBaseY - rotatedCoords.y;
          
          
          // payload object
          payload = payload || {};
          // payloa[legId]
          payload[legId] = payload[legId] || {};
          
          if (payload[legId].transverseBaseX)
            payload[legId].transverseBaseX += shiftX;
          else
            payload[legId].transverseBaseX = shiftX;
          
          if (payload[legId].transverseBaseY)
            payload[legId].transverseBaseY += shiftY;
          else
            payload[legId].transverseBaseY = shiftY;
        }
        return payload;
      }
      
      dispatchTickPayload(payload, currentTick, currentTickPct) {
        var action = [];
        
        // payload is not empty
        // payload can be empty when the current leg/stroke does not have any pixels to move
        if (payload)
          action.push({ type: "SEQUENCE_SHIFTED_XY_BATCHED", payload });
          
        action.push({ type: "MOVEMENT_ITERATION_PROPERTIES_CHANGED", payload: { currentTick, currentTickPct } })
        
        store.dispatch(action);
      }
      
      resetTickData() {
        store.dispatch({ type: "MOVEMENT_ITERATION_PROPERTIES_CHANGED", payload: { currentTick: 0, currentTickPct: 0 } });
      }
      
      disableSequencer() {
        store.dispatch({ type: "MOVEMENT_SETTINGS_CHANGED", payload: { sequencerEnabled: false } });
      }
      
      // stop sequencer
      clearSequencerInterval() {
        clearInterval(this.sequencerInterval);
        this.sequencerInterval = undefined;
      }
      
      observeSequencerEnabled(newValue, oldValue) {
        // sequencer enabled
        if (newValue === true)
          // start sequencer from where it stopped
          this.runSequence(this.iteration.currentTick + 1);
        // sequencer disabled
        else
          // stop sequencer
          this.clearSequencerInterval();
      }
      
      observeTimeline(newValue, oldValue) {
        // timeline is idle (null)
        if (newValue === null)
          // set the flag which will fail one condition when the sequencer is run
          this.sequencerIdle = true;
        // state changed from idle to active. not from active to active
        else if (newValue && oldValue === null) {
          // set the flag which shows that the timeline is not idle (null)
          this.sequencerIdle = false;
          // run the sequencer again if it is enabled
          if (this.sequencerEnabled) this.runSequence();
        }
      }

    }
    window.customElements.define(movementSequencer.is, movementSequencer);
  </script>
</dom-module>