<link rel="import" href="../../../../../bower_components/polymer/polymer-element.html">
<link rel="import" href="movement-sequencer/timeline-generator.html">

<dom-module id="movement-sequencer">
  <template>
    <timeline-generator timeline="{{timeline}}"></timeline-generator>
  </template>
  <script>
    class movementSequencer extends ReduxMixin(Polymer.Element) {
      static get is() { return 'movement-sequencer'; }
      static get properties() {
        return {
          enabled: {
            statePath: 'movement.settings.generatorEnabled',
            observer: 'observeEnabled'
          },
          iteration: {
            statePath: 'movement.iteration'
          },
          loop: {
            statePath: 'movement.settings.loop'
          },
          timeline: Object
        }
      }
      
      runSequencer(tick = 1) {
        // prevent multiple invocation
        if (this.sequencerInterval) {
          console.warn('Movement sequencer is already in progress');
          return;
        }
        
        // validation
        if (tick > this.iteration.amountOfTicks) {
          console.warn('Specified tick is greater that the amount of ticks in the iteration');
          return;
        }
        
        // iteration starts after (1000 / this.iteration.tps) amount of time with tick 1
        this.sequencerInterval = setInterval(() => {

          this.dispatchTickPayload(tick);          
          
          // check if that was the last tick
          if (tick === this.iteration.amountOfTicks) {
            // finish current iteration
            this.pauseSequencer();
            // reset progress when the iteration is complete
            this.resetTickData();
            
            // start iterating over again
            if (this.loop)
              this.runSequencer();
            // set generatorEnabled to false (disable movement sequencer)
            else
              this.disableSequencer();
          }
          
          // update tick value for the next tick interval
          tick++;
          
        }, 1000 / this.iteration.tps);
        
      }
      
      dispatchTickPayload(tick) {
        // payload is not empty
        if (this.timeline[tick].payload)
          store.dispatch({
            type: "SEQUENCE_SHIFTED_XY_BATCHED",
            payload: this.timeline[tick].payload,
            currentTick: tick,
            currentTickPct: this.timeline[tick].pct
          });
        // payload is empty, dispatch only currentTick and currentTickPct
        else
          store.dispatch({
            type: "MOVEMENT_ITERATION_VALUES_CHANGED",
            payload: {
              currentTick: tick,
              currentTickPct: this.timeline[tick].pct 
            }
          });
      }
      
      resetTickData() {
        store.dispatch({
          type: "MOVEMENT_ITERATION_VALUES_CHANGED",
          payload: { currentTick: 0, currentTickPct: 0 }
        });
      }
      
      disableSequencer() {
        store.dispatch({
          type: "MOVEMENT_SETTINGS_CHANGED",
          payload: { generatorEnabled: false }
        });
      }
      
      // clear sequencer interval
      pauseSequencer() {
        clearInterval(this.sequencerInterval);
        this.sequencerInterval = undefined;
      }
      
      observeEnabled(newValue, oldValue) {
        // start sequencer
        if (newValue === true)
          this.runSequencer(this.iteration.currentTick + 1);
        // pause sequencer
        else
          this.pauseSequencer();
      }

    }
    window.customElements.define(movementSequencer.is, movementSequencer);
  </script>
</dom-module>