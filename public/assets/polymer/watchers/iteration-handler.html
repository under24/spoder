<dom-module id="iteration-handler">
  <script>
    class iterationHandler extends ReduxMixin(Polymer.Element) {
      static get is() { return 'iteration-handler'; }
      static get properties() {
        return {
          circles: {
            statePath: 'movement.circles'
          },
          iteration: {
            statePath: 'movement.iteration'
          },
          iterationTick: {
            statePath: 'movement.iteration.currentTick',
            observer: 'observeIterationTick'
          },
          pointers: {
            statePath: 'movement.pointers',
            observer: 'observePointers'
          },
          settings: {
            statePath: 'movement.settings',
            observer: 'observeSettings'
          },
          coords: {
            statePath: 'coords'
          },
          directionJoystick: {
            statePath: 'movement.directionJoystick'
          },
          turnJoystick: {
            statePath: 'movement.turnJoystick'
          },
          // gaits: {
          //   statePath: 'gaits'
          // }
        };
      }
      
      generateTransitionShift() {
        let transitionShift = {};
        
        for (let legId = 1; legId <= 6; legId++) {
          transitionShift[legId] = this.generateLegData(legId);
        }
        
        let transitionShiftSource = {
          directionX: this.directionJoystick.x,
          directionY: this.directionJoystick.y,
          turnX: this.turnJoystick.x
        }
        
        this.dispatchTransitionShift({ transitionShift, transitionShiftSource });
      }
      
      generateLegData(legId) {
        return {
          transverseBaseX: this.circles[legId].x - this.pointers[legId].x,
          transverseBaseY: this.circles[legId].y - this.pointers[legId].y,
          transverseCursorX: this.coords[legId].transverseCursorX - this.pointers[legId].x,
          transverseCursorY: this.coords[legId].transverseCursorY - this.pointers[legId].y
        };
      }
      
      dispatchTransitionShift(payload) {
        // when the iteration is complete or has not been started
        if (this.iterationTick === 0)
          // try to pick up new properties (if there are) from movement.settings
          // new settings cannnot be applied in mid iteration
          this.mergeSettingsWithIteration(payload);
          
        store.dispatch({ type: "MOVEMENT_ITERATION_VALUES_CHANGED", payload });
      }
      
      mergeSettingsWithIteration(payload) {
        // state.movement.iteration.amountOfTicks
        let amountOfTicks = +(this.settings.duration / (1000 / this.settings.tps)).toFixed(0);
        
        if (this.iteration.amountOfTicks === null || this.iteration.amountOfTicks !== amountOfTicks)
          payload.amountOfTicks = amountOfTicks;
        
        // state.movement.iteration.tps
        if (this.iteration.tps === null || this.iteration.tps !== this.settings.tps)
          payload.tps = this.settings.tps;
        
        // state.movement.iteration.duration
        if (this.iteration.duration === null || this.iteration.duration !== this.settings.duration)
          payload.duration = this.settings.duration;
        
        // state.movement.iteration.gait
        if (this.iteration.gait === null || this.iteration.gait !== this.settings.gait)
          payload.gait = this.settings.gait;
      }
      
      // this function also picks up new settings when the current iteration is complete
      observeIterationTick(newValue) {
        if (newValue === 0) this.generateTransitionShift();
      }
      
      observePointers(newValue, oldValue) {
        // if initialization then quit and wait for the next call
        if (oldValue === undefined) return;
        
        // if not same values
        if (this.turnJoystick.x !== this.iteration.transitionShiftSource.turnX ||
            this.directionJoystick.x !== this.iteration.transitionShiftSource.directionX ||
            this.directionJoystick.y !== this.iteration.transitionShiftSource.directionY
        ) this.generateTransitionShift();
      }
      
      // watch state.movement.settings and update state.movement.iteration with the new value from seetings if the iteration has not been started
      observeSettings(newValue, oldValue) {
        // skip init. the transition shift obj is going to be generated anyway
        if (oldValue === undefined) return;
        
        // do not update iteration data if movement is in process. wait for tick === 0
        if (this.iterationTick !== 0) return;
        
        // if one of the important settings properties changed then update the state iteration data
        if (newValue.tps !== oldValue.tps || newValue.duration !== oldValue.duration || newValue.gait !== oldValue.gait) {
          let payload = {};
          this.mergeSettingsWithIteration(payload);
          
          store.dispatch({ type: "MOVEMENT_ITERATION_VALUES_CHANGED", payload });
        }
      }

    }
    window.customElements.define(iterationHandler.is, iterationHandler);
  </script>
</dom-module>