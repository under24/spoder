<dom-module id="iteration-generator">
  <script>
    class iterationGenerator extends ReduxMixin(Polymer.Element) {
      static get is() { return 'iteration-generator'; }
      static get properties() {
        return {
          circles: {
            statePath: 'movement.circles'
          },
          iteration: {
            statePath: 'movement.iteration'
          },
          iterationTick: {
            statePath: 'movement.iteration.currentTick'
          },
          pointers: {
            statePath: 'movement.pointers'
          },
          settings: {
            statePath: 'movement.settings',
            observer: 'observeSettings'
          },
          coords: {
            statePath: 'coords'
          },
          directionJoystick: {
            statePath: 'movement.directionJoystick'
          },
          turnJoystick: {
            statePath: 'movement.turnJoystick'
          }
        };
      }
      
      static get observers() {
        return [ 'processNewTransitionShift(iterationTick, pointers)' ];
      }
      
      processNewTransitionShift(iterationTick) {
        // validation: joystick values changed or iterationTick is 0
        if (this.invalidConditions(iterationTick)) return;
        
        var transitionShift = this.generateTransitionShift(),
            transitionShiftSource = this.generateTransitionShiftSource();
            
        // prepare payload for dispatching
        var payload = { transitionShift, transitionShiftSource };
        
        // when the iteration is complete or has not been started. new settings cannnot be applied in mid iteration
        if (iterationTick === 0)
          // try to pick up new properties (if there are) from movement.settings
          this.mergeSettingsWithIteration(payload);
        
        // dispatch transitionShift + transitionShiftSource + maybe new settings
        this.dispatchIterationValues(payload);
      }
      
      invalidConditions(iterationTick) {
        // this check is first because this.iteration.transitionShiftSource is null during initialization
        // generate new transitionShift every time iterationTick is 0
        if (iterationTick === 0) 
          // valid condition
          return false;
        
        // if  one of the joysticks has changed its values then we generate new transitionShift
        if (this.turnJoystick.x !== this.iteration.transitionShiftSource.turnX ||
            this.directionJoystick.x !== this.iteration.transitionShiftSource.directionX ||
            this.directionJoystick.y !== this.iteration.transitionShiftSource.directionY)
          // valid condition
          return false;
        
        // invalid conditions
        return true;
      }
      
      generateTransitionShift() {
        var transitionShift = {};
        
        for (let legId = 1; legId <= 6; legId++) {
          transitionShift[legId] = {
            transverseBaseX: this.circles[legId].x - this.pointers[legId].x,
            transverseBaseY: this.circles[legId].y - this.pointers[legId].y,
            transverseCursorX: this.coords[legId].transverseCursorX - this.pointers[legId].x,
            transverseCursorY: this.coords[legId].transverseCursorY - this.pointers[legId].y
          };
        }
        
        return transitionShift;
      }
      
      generateTransitionShiftSource() {
        return {
          directionX: this.directionJoystick.x,
          directionY: this.directionJoystick.y,
          turnX: this.turnJoystick.x
        };
      }
      
      dispatchIterationValues(payload) {
        store.dispatch({ type: "MOVEMENT_ITERATION_VALUES_CHANGED", payload });
      }
      
      mergeSettingsWithIteration(payload) {
        // state.movement.iteration.amountOfTicks
        let amountOfTicks = +(this.settings.duration / (1000 / this.settings.tps)).toFixed(0);
        // if init state or settings changed
        if (!this.iteration.amountOfTicks || this.iteration.amountOfTicks !== amountOfTicks)
          payload.amountOfTicks = amountOfTicks;
        
        // if init state or settings changed. state.movement.iteration.tps
        if (!this.iteration.tps || this.iteration.tps !== this.settings.tps)
          payload.tps = this.settings.tps;
        
        // if init state or settings changed. state.movement.iteration.duration
        if (!this.iteration.duration || this.iteration.duration !== this.settings.duration)
          payload.duration = this.settings.duration;
        
        // if init state or settings changed. state.movement.iteration.gait
        if (!this.iteration.gait || this.iteration.gait !== this.settings.gait)
          payload.gait = this.settings.gait;
          
        // if init state or settings changed. state.movement.iteration.sequencerMode
        if (!this.iteration.sequencerMode || this.iteration.sequencerMode !== this.settings.sequencerMode)
          payload.sequencerMode = this.settings.sequencerMode;
      }
      
      // watch state.movement.settings and update state.movement.iteration with the new value from seetings if the iteration has not been started
      processNewIterationValues(newSettings, oldSettings) {
        // validation: skip initialization, wait for tick 0, only observable setting property changed
        if (this.invalidSettings(newSettings, oldSettings)) return;
        
        // prepare payload object for dispatching
        var payload = {};
        // fill in payload with new settings
        this.mergeSettingsWithIteration(payload);
        // dispatch iteration values
        this.dispatchIterationValues(payload);
      }
      
      invalidSettings(newSettings, oldSettings) {
        // skip init. the transition shift obj is going to be generated anyway
        if (oldSettings === undefined)
          // invalid condition
          return true;
          
        // do not update iteration data if movement is in process. wait for tick === 0
        if (this.iterationTick !== 0)
          // invalid condition
          return true;
          
        // if one of the observable settings changed then update the state iteration data
        if (newSettings.tps === oldSettings.tps &&
            newSettings.duration === oldSettings.duration &&
            newSettings.gait === oldSettings.gait &&
            newSettings.sequencerMode === oldSettings.sequencerMode)
          // invalid condition
          return true;
        
        // valid conditions
        return false;
      }

    }
    iterationGenerator.prototype.observeSettings = iterationGenerator.prototype.processNewIterationValues;
    window.customElements.define(iterationGenerator.is, iterationGenerator);
  </script>
</dom-module>