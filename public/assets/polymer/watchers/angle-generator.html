<link rel="import" href="angle-generator/base-generator.html">
<link rel="import" href="angle-generator/misc-generator.html">
<link rel="import" href="angle-generator/circle-generator.html">

<dom-module id="angle-generator">
  <template>
    <base-generator id="baseGenerator"></base-generator>
    <misc-generator id="miscGenerator"></misc-generator>
    <circle-generator id="circleGenerator"></circle-generator>
  </template>
  <script>
    class angleGenerator extends ReduxMixin(Polymer.Element) {
      static get is() { return 'angle-generator'; }
      static get properties() {
        return {
          metaData: {
            statePath: 'metaData'
          },
          angles: {
            statePath: 'angles'
          },
          coords: {
            statePath: 'coords',
            observer: 'observeCoords'
          },
          coxaAttachmentAngles: {
            statePath: 'base.coxaAttachmentAngles'
          }
        };
      }
      
      getDistanceFromBaseToCursor(legId, view) {
        return MU.getDistance(this.getDX(legId, view), this.getDY(legId, view));
      }
      
      getDX(legId, view) {
        return this.coords[legId][`${view}CursorX`] - this.coords[legId][`${view}BaseX`];
      }
      
      getDY(legId, view) {
        return this.coords[legId][`${view}CursorY`] - this.coords[legId][`${view}BaseY`];
      }
      
      getReachDistance(legId, view) {
        return this.getDistanceFromBaseToCursor(legId, view) - this.metaData.combinedLegsLength;
      }
      
      targetWithinReach(legId, view) {
        return this.getReachDistance(legId, view) > 0 ? false : true;
      }

      getAngleFromDistance(legId, view) {
        var screen = MU.getAngle(this.getDY(legId, view), this.getDX(legId, view)),
            servo = GU.correctAngle(screen + 90);
        
        return {
          screen: GU.correctAngle(screen),
          servo: +servo.toFixed(0)
        };
      }
      
      sameCoords(newCoords, oldCoords, view) {
        if (newCoords[`${view}CursorX`] !== oldCoords[`${view}CursorX`] ||
            newCoords[`${view}CursorY`] !== oldCoords[`${view}CursorY`] ||
            newCoords[`${view}BaseX`] !== oldCoords[`${view}BaseX`] ||
            newCoords[`${view}BaseY`] !== oldCoords[`${view}BaseY`]) return false;
            
        return true;
      }
      
      processNewCoxaAngles(legId) {
        var coxaAngles = this.getAngleFromDistance(legId, 'transverse');
            
        return {
          coxaScreenAngle: coxaAngles.screen,
          coxaServoAngle: this.applyCoxaAttachmentAngle(legId, coxaAngles.servo)
        };
      }
      
      processNewFemurAndTibiaAngles(legId) {
        // within reach
        if (this.targetWithinReach(legId, 'sagittal'))
          return this.calcForWithinReachMode(legId, 'sagittal');
        // out of reach
        else
          return this.calcForOutOfReachMode(legId, 'sagittal');
      }
      
      calcForWithinReachMode(legId, view) {
        var femurAngles = this.getFemurAngle(legId, view),
            tibiaAngles = this.getTibiaAngle(legId, view);
        
        return {
          femurScreenAngle: femurAngles.screen,
          femurServoAngle: femurAngles.servo,
          tibiaScreenAngle: tibiaAngles.screen,
          tibiaServoAngle: tibiaAngles.servo
        }
      }
      
      calcForOutOfReachMode(legId, view) {
        var femurAngles = this.getAngleFromDistance(legId, view);
        
        return {
          femurScreenAngle: femurAngles.screen,
          femurServoAngle: femurAngles.servo,
          tibiaScreenAngle: 0,
          tibiaServoAngle: 0
        }
      }
      
      getFemurAngle(legId, view) {
        var D1 = Math.atan2(this.getDY(legId, view), this.getDX(legId, view)),
            D2 = MU.lawOfCos(this.getDistanceFromBaseToCursor(legId, view), this.metaData.femurLength, this.metaData.tibiaLength);

        var A1 = D2 - D1;
        
        var A1Screen = A1 / Math.PI * -180,
            A1Servo = A1Screen + 90;
            
        // correct angle (-55 -> 305)
        var screen = GU.correctAngle(A1Screen);
        // apply decimal precision
        var servo = +A1Servo.toFixed(0)
        
        return { screen, servo };
      }
      
      getTibiaAngle(legId, view) {
        var A2 = MU.lawOfCos(this.metaData.femurLength, this.metaData.tibiaLength, this.getDistanceFromBaseToCursor(legId, view));
        
        var A2Screen = 180 - (A2 / Math.PI * 180),
            A2Servo = A2Screen;
        
        return { screen: A2Screen, servo: +A2Servo.toFixed(0) };
      }
      
      applyCoxaAttachmentAngle(legId, coxaServoAngle) {
        // correct angle so it is 0 deg
        switch (legId) {
          case 1:
            coxaServoAngle -= this.coxaAttachmentAngles[legId]; break;
          case 2:
            coxaServoAngle -= this.coxaAttachmentAngles[legId]; break;
          case 4:
            coxaServoAngle -= this.coxaAttachmentAngles[legId]; break;
          case 5:
            coxaServoAngle -= this.coxaAttachmentAngles[legId]; break;
          case 6:
            coxaServoAngle -= this.coxaAttachmentAngles[legId]; break;
        }
        
        return GU.correctAngle(coxaServoAngle);
      }
      
      emitAngles(angles) {
        // obj for storing filtered out servo angles
        var servoAngles = {};
        
        // loop through the payload obj and filter out servo angles
        for (let legId in angles) {
          // check if coxa servo angle is present
          if ('coxaServoAngle' in angles[legId]) {
            // check if the obj is created
            servoAngles[legId] = servoAngles[legId] || {};
            // assign a value
            servoAngles[legId].coxaServoAngle = angles[legId].coxaServoAngle;
          }
          // check if femur servo angle is present
          if ('femurServoAngle' in angles[legId]) {
            // check if the obj is created
            servoAngles[legId] = servoAngles[legId] || {};
            // assign a value
            servoAngles[legId].femurServoAngle = angles[legId].femurServoAngle;
          }
          // check if tibia servo angle is present
          if ('tibiaServoAngle' in angles[legId]) {
            // check if the obj is created
            servoAngles[legId] = servoAngles[legId] || {};
            // assign a value
            servoAngles[legId].tibiaServoAngle = angles[legId].tibiaServoAngle;
          }
        }
        
        // if there are some servo angles then send to the back end
        if (Object.keys(servoAngles).length !== 0)
          socket.emit('servo-angles-changed', servoAngles);
        
        // TODO temp. for debugging purposes
        if (angles[1] && angles[1].coxaServoAngle)
          socket.emit('femur-servo-angle-changed', { value: angles[1].coxaServoAngle });
      }
      
      observeCoords(newCoords, oldCoords) {
        var anglesPayload = {},
            miscPayload = {}, 
            circlesPayload = {};
            
        var baseCenterCoords = this.$.baseGenerator.processNewBaseCenterCoords(newCoords),
            baseDirection = this.$.baseGenerator.processNewBaseDirection(newCoords, baseCenterCoords);
            
        for (let legId = 1; legId <= 6; legId++) {
          // transverse coords
          if (!oldCoords || !this.sameCoords(newCoords[legId], oldCoords[legId], 'transverse')) {
            // transverse coords -> coxa angles
            let coxaAngles = this.processNewCoxaAngles(legId);
            // prepare payload obj by filtering out duplicate values before dispatching
            GU.sieveOutAndGatherUp(coxaAngles, this.angles[legId], anglesPayload, legId);
          }
          
          // sagittal coords
          if (!oldCoords || !this.sameCoords(newCoords[legId], oldCoords[legId], 'sagittal')) {
            // sagittal coords -> femur + tibia angles
            let femurAndTibiaAngles = this.processNewFemurAndTibiaAngles(legId);
            // prepare payload obj by filtering out duplicate values before dispatching
            GU.sieveOutAndGatherUp(femurAndTibiaAngles, this.angles[legId], anglesPayload, legId);
            
            // misc
            let miscValue = this.$.miscGenerator.processNewMisc(this, legId);
            // prepare payload obj by filtering out duplicate values before dispatching
            this.$.miscGenerator.sieveOutAndGatherUp(legId, miscValue, miscPayload);
            
            // movement circles
            let circle = this.$.circleGenerator.processNewCircle(legId, miscValue.transverseReachRadius, newCoords[legId], baseDirection, baseCenterCoords);
            // prepare payload obj by filtering out duplicate values before dispatching
            this.$.circleGenerator.sieveOutAndGatherUp(legId, circle, circlesPayload);
          }
        }

        // dispatch
        this.dispatchAngles(anglesPayload);
        this.$.baseGenerator.dispatchBaseDirection(baseDirection);
        this.$.baseGenerator.dispatchBaseCenterCoords(baseCenterCoords);
        this.$.miscGenerator.dispatchMisc(miscPayload);
        this.$.circleGenerator.dispatchCirles(circlesPayload);
      }
      
      dispatchAngles(payload) {
        // empty payload object
        if (Object.keys(payload).length === 0) return;

        // send the angles to the back end
        this.emitAngles(payload);
        
        store.dispatch({ type: "ANGLES_CHANGED_BATCHED", payload });
      }

    }
    window.customElements.define(angleGenerator.is, angleGenerator);
  </script>
</dom-module>