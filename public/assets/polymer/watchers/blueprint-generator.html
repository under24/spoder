<dom-module id="blueprint-generator">
  <script>
    class blueprintGenerator extends ReduxMixin(Polymer.Element) {
      static get is() { return 'blueprint-generator'; }
      static get properties() {
        return {
          transitionShift: {
            statePath: 'movement.iteration.transitionShift'
          },
          iterationGait: {
            statePath: 'movement.iteration.gait'
          },
          gaits: {
            statePath: 'gaits'
          }
        }
      }
      
      // generate a new blueprint whenever this.transitionShift || this.iterationGait changes and dispatch it
      static get observers() {
        return [ 'processNewBlueprint(transitionShift, iterationGait)' ];
      }
      
      processNewBlueprint() {
        // create a new blueprint
        var blueprint = this.generateBlueprint();
        // dispatch it
        store.dispatch({ type: "MOVEMENT_ITERATION_VALUES_CHANGED", payload: { blueprint } });
      }
      
      generateBlueprint() {
        var blueprint = {};
        
        // blueprint has to data to move (=== idle)
        if (this.idleBlueprint()) blueprint = null;
        // blueprint will have some data to move thus need to raise every leg
        else {
          for (let legId = 1; legId <= 6; legId++) {
            blueprint[legId] = this.fillInLegData(this.gaits[this.iterationGait].legTimings[legId], this.transitionShift[legId]);
          }
        }
        
        return blueprint;
      }
      
      fillInLegData(legTimings, transitionShift) {
        // current leg blueprint data
        var result = [];
        
        // moves the base
        this.addTransverseBaseXY(result, transitionShift);
        // moves the legs
        this.addTransverseCursorXY(result, legTimings, transitionShift);
        // raises the legs
        this.addSagittalCursorY(result, legTimings, transitionShift);
        
        return result;
        
        // return [
        //   {
        //     coordType: "transverseBaseX",
        //     startPct: 0,
        //     endPct: 100,
        //     pxlsToMove: transitionShift.transverseBaseX
        //   },
        //   {
        //     coordType: "transverseBaseY",
        //     startPct: 0,
        //     endPct: 100,
        //     pxlsToMove: transitionShift.transverseBaseY
        //   },
        //   {
        //     coordType: "transverseCursorX",
        //     startPct: legTimings.startPct,
        //     endPct: legTimings.endPct,
        //     pxlsToMove: transitionShift.transverseCursorX
        //   },
        //   {
        //     coordType: "transverseCursorY",
        //     startPct: legTimings.startPct,
        //     endPct: legTimings.endPct,
        //     pxlsToMove: transitionShift.transverseCursorY
        //   },
        //   {
        //     coordType: "sagittalCursorY",
        //     startPct: legTimings.startPct,
        //     endPct: legTimings.startPct + ((legTimings.endPct - legTimings.startPct) / 2),
        //     pxlsToMove: 20
        //   },
        //   {
        //     coordType: "sagittalCursorY",
        //     startPct: legTimings.endPct - ((legTimings.endPct - legTimings.startPct) / 2),
        //     endPct: legTimings.endPct,
        //     pxlsToMove: -20
        //   }
        // ];
      }
      
      addTransverseBaseXY(result, transitionShift) {
        // transverseBaseX
        if (MU.notEmpty(transitionShift['transverseBaseX'])) {
          let tbx = this.buildDataObject('transverseBaseX', 0, 100, transitionShift.transverseBaseX);
          result.push(tbx);
        }
        // transverseBaseY
        if (MU.notEmpty(transitionShift['transverseBaseY'])) {
          let tby = this.buildDataObject('transverseBaseY', 0, 100, transitionShift.transverseBaseY);
          result.push(tby);
        }
      }
      
      addTransverseCursorXY(result, legTimings, transitionShift) {
        // transverseCursorX
        if (MU.notEmpty(transitionShift['transverseCursorX'])) {
          let tcx =  this.buildDataObject('transverseCursorX', legTimings.startPct, legTimings.endPct, transitionShift.transverseCursorX);
          result.push(tcx);
        }
        // transverseCursorY
        if (MU.notEmpty(transitionShift['transverseCursorY'])) {
          let tcy = this.buildDataObject('transverseCursorY', legTimings.startPct, legTimings.endPct, transitionShift.transverseCursorY);
          result.push(tcy);
        }
      }
      
      addSagittalCursorY(result, legTimings, transitionShift) {
        var strokeMedian = legTimings.startPct + (legTimings.endPct - legTimings.startPct) / 2;
        
        var raise = this.buildDataObject('sagittalCursorY', legTimings.startPct, strokeMedian, 20);
        var lower = this.buildDataObject('sagittalCursorY', strokeMedian, legTimings.endPct, -20);
        
        result.push(raise, lower);
      }
      
      buildDataObject(coordType, startPct, endPct, pxlsToMove) {
        return { coordType, startPct, endPct, pxlsToMove };
      }
      
      idleBlueprint() {
        // iterate leg IDs
        for (let legId in this.transitionShift) {
          // iterate coords with shift data
          for (let coordShift in this.transitionShift[legId]) {
            // blueprint is not idle
            if (MU.notEmpty(this.transitionShift[legId][coordShift])) return false;
          }
        }
        
        // blueprint is idle (has no data to move)
        return true;
      }

    }
    window.customElements.define(blueprintGenerator.is, blueprintGenerator);
  </script>
</dom-module>