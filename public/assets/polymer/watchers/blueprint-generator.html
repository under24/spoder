<dom-module id="blueprint-generator">
  <script>
    class blueprintGenerator extends ReduxMixin(Polymer.Element) {
      static get is() { return 'blueprint-generator'; }
      static get properties() {
        return {
          transitionShift: {
            statePath: 'movement.iteration.transitionShift'
          },
          iterationGait: {
            statePath: 'movement.iteration.gait'
          },
          gaits: {
            statePath: 'gaits'
          }
        }
      }
      
      // generate a new blueprint whenever this.transitionShift || this.iterationGait changes and dispatch it
      static get observers() {
        return [ 'processNewBlueprint(transitionShift, iterationGait)' ];
      }
      
      processNewBlueprint() {
        // create a new blueprint
        var blueprint = this.generateBlueprint();
        // dispatch it
        this.dispatchBlueprint(blueprint);
      }
      
      generateBlueprint() {
        var blueprint = {};
        
        for (let legId = 1; legId <= 6; legId++) {
          blueprint[legId] = this.fillInBlueprintData(this.gaits[this.iterationGait].legTimings[legId], this.transitionShift[legId]);
        }
        
        return blueprint;
      }
      
      fillInBlueprintData(legTimings, movementData) {
        // TODO REFACTOR
        
        var result = [];
        
        // transverseBaseX
        if (!this.empty(movementData['transverseBaseX'])) {
          result.push({
            coordType: 'transverseBaseX',
            startPct: 0,
            endPct: 100,
            pxlsToMove: movementData.transverseBaseX
          });
        }
        
        // transverseBaseY
        if (!this.empty(movementData['transverseBaseY'])) {
          result.push({
            coordType: 'transverseBaseY',
            startPct: 0,
            endPct: 100,
            pxlsToMove: movementData.transverseBaseY
          });
        }
        
        // transverseCursorX
        if (!this.empty(movementData['transverseCursorX'])) {
          result.push({
            coordType: 'transverseCursorX',
            startPct: legTimings.startPct,
            endPct: legTimings.endPct,
            pxlsToMove: movementData.transverseCursorX
          });
        }
        
        // transverseCursorY
        if (!this.empty(movementData['transverseCursorY'])) {
          result.push({
            coordType: 'transverseCursorY',
            startPct: legTimings.startPct,
            endPct: legTimings.endPct,
            pxlsToMove: movementData.transverseCursorY
          });
        }
        
        var half = legTimings.startPct + (legTimings.endPct - legTimings.startPct) / 2;
        
        // sagittalCursorY
        if (!this.empty(movementData['transverseCursorX']) || !this.empty(movementData['transverseCursorY'])) {
          result.push({
            coordType: 'sagittalCursorY',
            startPct: legTimings.startPct,
            endPct: half,
            pxlsToMove: 20
          });
        }
        
        // sagittalCursorY
        if (!this.empty(movementData['transverseCursorX']) || !this.empty(movementData['transverseCursorY'])) {
          result.push({
            coordType: 'sagittalCursorY',
            startPct: half,
            endPct: legTimings.endPct,
            pxlsToMove: -20
          });
        }
        
        return result;
        
        // return [
        //   {
        //     coordType: "transverseBaseX",
        //     startPct: 0,
        //     endPct: 100,
        //     pxlsToMove: movementData.transverseBaseX
        //   },
        //   {
        //     coordType: "transverseBaseY",
        //     startPct: 0,
        //     endPct: 100,
        //     pxlsToMove: movementData.transverseBaseY
        //   },
        //   {
        //     coordType: "transverseCursorX",
        //     startPct: legTimings.startPct,
        //     endPct: legTimings.endPct,
        //     pxlsToMove: movementData.transverseCursorX
        //   },
        //   {
        //     coordType: "transverseCursorY",
        //     startPct: legTimings.startPct,
        //     endPct: legTimings.endPct,
        //     pxlsToMove: movementData.transverseCursorY
        //   },
        //   {
        //     coordType: "sagittalCursorY",
        //     startPct: legTimings.startPct,
        //     endPct: legTimings.startPct + ((legTimings.endPct - legTimings.startPct) / 2),
        //     pxlsToMove: 20
        //   },
        //   {
        //     coordType: "sagittalCursorY",
        //     startPct: legTimings.endPct - ((legTimings.endPct - legTimings.startPct) / 2),
        //     endPct: legTimings.endPct,
        //     pxlsToMove: -20
        //   }
        // ];
      }
      
      // checks if the value is close to 0
      empty(pxlsToMove) {
        return pxlsToMove < 0.01 && pxlsToMove > -0.01;
      }
      
      dispatchBlueprint(blueprint) {        
        store.dispatch({ type: "MOVEMENT_ITERATION_VALUES_CHANGED", payload: { blueprint } });
      }

    }
    window.customElements.define(blueprintGenerator.is, blueprintGenerator);
  </script>
</dom-module>