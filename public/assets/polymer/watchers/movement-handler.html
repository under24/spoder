<link rel="import" href="../../../../../bower_components/polymer/polymer-element.html">

<dom-module id="movement-handler">
  <script>
    class movementHandler extends ReduxMixin(Polymer.Element) {
      static get is() { return 'movement-handler'; }
      static get properties() {
        return {
          enabled: {
            statePath: 'movement.settings.generatorEnabled',
            observer: 'observeEnabled'
          },
          gaits: {
            statePath: 'gaits'
          },
          loop: {
            statePath: 'movement.settings.loop'
          },
          iteration: {
            statePath: 'movement.iteration'
          },
          // for calc of turn values
          turnJoystick: {
            statePath: 'movement.turnJoystick'
          },
          // for calc of turn values
          baseCenterCoords: {
            statePath: 'base.centerCoords'
          },
          // for calc of turn values
          coords: {
            statePath: 'coords'
          }
        };
      }
      
      runGenerator(tick = 1) {
        // prevent multiple invocation
        if (this.generatorInterval) {
          console.warn('Movement generator is already in progress');
          return;
        }
        
        // validation
        if (tick > this.iteration.amountOfTicks) {
          console.warn('Specified tick is bigger that the amount in the iteration');
          return;
        }
        
        // iteration starts after (1000 / this.iteration.tps) amount of time with tick 1
        this.generatorInterval = setInterval(() => {
          // generate tick value
          let payload = this.generateTickPayload(tick);
          
          // dispatch tick data
          store.dispatch({
            type: "SEQUENCE_SHIFTED_XY_BATCHED",
            payload: payload,
            currentTick: tick,
            currentTickPct: this.calcTickPct(tick, this.iteration.amountOfTicks)
          });
          
          // check if that was the last tick
          if (tick === this.iteration.amountOfTicks) {
            // finish current iteration
            this.clearGeneratorInterval();
            
            // reset progress when the iteration is complete
            store.dispatch({
              type: "MOVEMENT_ITERATION_VALUES_CHANGED",
              payload: { currentTick: 0, currentTickPct: 0 }
            });
            
            // start iterating over again
            if (this.loop)
              this.runGenerator();
            // set generatorEnabled to false (disable movement generator)
            else
              store.dispatch({
                type: "MOVEMENT_SETTINGS_CHANGED",
                payload: { generatorEnabled: false }
              });
          }
          
          // update tick value for the next tick interval
          tick++;
          
        }, 1000 / this.iteration.tps);
        
      }
      
      clearGeneratorInterval() {
        clearInterval(this.generatorInterval);
        this.generatorInterval = undefined;
      }
      
      pauseGenerator() {
        this.clearGeneratorInterval();
      }
      
      runOrResumeGenerator() {
        this.runGenerator(this.iteration.currentTick + 1);
      }
      
      generateTickPayload(tick) {
        let amountOfTicks = this.iteration.amountOfTicks,
            // legs which are used in the current stroke of the iteration
            legsUsedInCurrentStroke = this.getLegsUsedInCurrentStroke(tick),
            // full iteration movement data
            iterationMovementData = this.iteration.transitionShift,
            // payload values (current tick/step values for dispatching)
            payload = {};
            
        for (let legId = 1; legId <= 6; legId++) {
          payload[legId] = this.calcStepValues(legId, legsUsedInCurrentStroke, amountOfTicks, iterationMovementData);
        }
        
        // dispatch values
        return payload;
      }
      
      calcTickPct(tick, amountOfTicks) {
        return MU.roundNumber(100 / amountOfTicks * tick, 1);
      }
      
      getLegsUsedInCurrentStroke(currentTick) {
        let sequence = this.gaits[this.iteration.gait].sequence,
            strokeTickMap = this.iteration.strokeTickMap;
        
        // find current legs based on the stroke tick map (for the current iteration)
        for (let i = 0; i < strokeTickMap.length; i++) {
          // start tick <= current tick <= end tick
          if (strokeTickMap[i].startTick <= currentTick && currentTick <= strokeTickMap[i].endTick) 
            return sequence[i];
        }
        
        // not found. must be an error. it should always be found
        return null;
      }
      
      calcStepValues(legId, usedLegs, amountOfTicks, iterationMovementData) {
        let result = {};
        
        // calc direction values
        this.calcDirectionStepValues(result, amountOfTicks, legId, iterationMovementData, usedLegs);
        
        // calc turn calcStepValues
        this.calcTurnStepValues(result, amountOfTicks, legId);

        return result;
      }
      
      calcDirectionStepValues(result, amountOfTicks, legId, iterationMovementData, usedLegs) {
        // base stroke pct
        let baseStrokePcts = { startPct: 0, endPct: 100 };
        
        // calc transverseBaseX/Y values
        result.transverseBaseX = this.calcTickValue(amountOfTicks, iterationMovementData[legId].transverseBaseX, baseStrokePcts);
        result.transverseBaseY = this.calcTickValue(amountOfTicks, iterationMovementData[legId].transverseBaseY, baseStrokePcts);
        
        // if legId is one of the currently used legs then add cursor data to the return object
        if (~usedLegs.indexOf(legId)) {
          // cursor stroke pct
          let cursorStrokePcts = this.gaits[this.iteration.gait].legTimings[legId];
          
          // calc transverseCursorX/Y values
          result.transverseCursorX = this.calcTickValue(amountOfTicks, iterationMovementData[legId].transverseCursorX, cursorStrokePcts);
          result.transverseCursorY = this.calcTickValue(amountOfTicks, iterationMovementData[legId].transverseCursorY, cursorStrokePcts);
        };
      }
      
      calcTurnStepValues(result, amountOfTicks, legId) {
        // apply movement.turnJoystick values (min-in turn values to the direction ones)
        if (this.turnJoystick.x) {
          // angle / amount of ticks = angle for each tick
          let stepAngle = MU.flipNumber(this.turnJoystick.x) / amountOfTicks;
          
          // find rotated base coords
          let rotatedCoords = RU.getRotatedCoords(this.baseCenterCoords, stepAngle, this.coords[legId]);
          
          // get turn shift values
          let shiftX = this.coords[legId].transverseBaseX - rotatedCoords.x,
              shiftY = this.coords[legId].transverseBaseY - rotatedCoords.y;
              
          // add turn values to the result object
          result.transverseBaseX += shiftX;
          result.transverseBaseY += shiftY;
        }
      }
      
      calcTickValue(amountOfTicks, pixelsToMove, strokePcts) {
        let startTick = this.getClosestTick(strokePcts.startPct, amountOfTicks) + 1, // because it starts from the next tick
            endTick = this.getClosestTick(strokePcts.endPct, amountOfTicks),
            ticksBetweenStartAndEnd = this.getAmountOfTicksBetween(startTick, endTick),
            tickValue = this.calcTickValueBasedOnPxlsToMove(ticksBetweenStartAndEnd, pixelsToMove);
            
        return tickValue;
      }
      
      getClosestTick(targetPct, amountOfTicks) {
        let closestTick = 0;
        
        let diff = targetPct;
        for (let tick = 1; tick <= amountOfTicks; tick++) {
          let iteratedTickPct = this.calcTickPct(tick, amountOfTicks);
          
          let newDiff = Math.abs(targetPct - iteratedTickPct);
          if (newDiff < diff) {
            diff = newDiff;
            closestTick = tick;
          }
        }
        return +closestTick;
      }
      
      getAmountOfTicksBetween(startTick, endTick) {
        return (endTick - startTick) + 1;
      }
      
      calcTickValueBasedOnPxlsToMove(amountOfTicks, pixelsToMove) {
        return pixelsToMove / amountOfTicks;
      }
      
      observeEnabled(newValue, oldValue) {
        // movement enabled
        if (newValue === true)
          this.runOrResumeGenerator();
        // movement disabled
        else
          this.pauseGenerator();
      }

    }
    window.customElements.define(movementHandler.is, movementHandler);
  </script>
</dom-module>