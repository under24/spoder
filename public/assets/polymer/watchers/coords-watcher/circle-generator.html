<dom-module id="circle-generator">
  <script>
    class circleGenerator extends ReduxMixin(Polymer.Element) {
      static get is() { return 'circle-generator'; }
      static get properties() {
        return {
          turnJoystick: {
            statePath: 'movement.turnJoystick',
            observer: 'observeTurnJoystick'
          },
          misc: {
            statePath: 'misc'
          },
          coords: {
            statePath: 'coords'
          },
          base: {
            statePath: 'base'
          },
          metaData: {
            statePath: 'metaData'
          },
          circles: {
            statePath: 'movement.circles'
          }
        };
      }
      
      processNewCircle(legId, transverseReachRadius, coords, baseDirection = this.base.direction, baseCenterCoords = this.base.centerCoords) {
        var circleDiameter = transverseReachRadius - this.metaData.impossibleRange,
            tbx = coords.transverseBaseX,
            tby = coords.transverseBaseY,
            coxaAttachment = this.base.coxaAttachmentAngle[legId],
            side = GU.getLegSide(legId);
        
        // distance to the center of the circle + offset from impossible range
        var distance = (transverseReachRadius + this.metaData.impossibleRange) / 2;
            
        // sum up coxaAttachment + baseDirection - turnJoystick
        switch (side) {
          case 'left':
            var angle = coxaAttachment + baseDirection - this.turnJoystick.x; break;
          case 'right':
            var angle = MU.flipNumber(coxaAttachment + baseDirection - this.turnJoystick.x); break;
        }
        
        // find circleCenterCoords + solidX/Y if the turn joystick is not centered (!== 0)
        if (this.turnJoystick.x) {
          // turn base coords
          var { x: turnedBaseX, y: turnedBaseY } = RU.getRotatedCoords(baseCenterCoords, MU.flipNumber(this.turnJoystick.x), coords, side);

          // find circle center coords (fluent)
          var circleCenterCoords = MU.getCoordsFromDistanceAndAngle(turnedBaseX, turnedBaseY, angle, distance);
          
          // find solid angle (the way the leg is attached to the base)
          switch (side) {
            case 'left':
              var solidAngle = coxaAttachment + baseDirection; break;
            case 'right':
              var solidAngle = MU.flipNumber(coxaAttachment + baseDirection); break;
          }
          
          // solid (unturned) circle center coords
          var { x: solidX, y: solidY } = MU.getCoordsFromDistanceAndAngle(tbx, tby, solidAngle, distance);
        }
        // turn joystick is centered (x: 0)
        else
          var circleCenterCoords = MU.getCoordsFromDistanceAndAngle(tbx, tby, angle, distance);
          
        return {
          // for when the leg is raised. the circle should have solid position so it does not move when the leg is raised
          x: circleCenterCoords.x,
          y: circleCenterCoords.y,
          solidX,
          solidY,
          fluentTransverseBaseX: turnedBaseX,
          fluentTransverseBaseY: turnedBaseY,
          fluentRadius: circleDiameter / 2,
          fluentDiameter: circleDiameter,
          radius: 80, // 80
          diameter: 160 // 160
        }
      }
      
      gatherCircles(legId, circle, payload) {
        payload[legId] = circle;
      }
      
      validateAndDispatchMovementCircles(payload) {
        // empty payload object
        if (Object.keys(payload).length === 0) return;
        
        store.dispatch({ type: "MOVEMENT_CIRCLES_CHANGED_BATCHED", payload });
      }
      
      observeTurnJoystick(newValue, oldValue) {
        // skip init because circles will be generated in the observeCoords function
        if (oldValue === undefined) return;
        
        let circlesPayload = {};
        
        for (let legId = 1; legId <= 6; legId++) {
          let circle = this.processNewCircle(legId, this.misc[legId].transverseReachRadius, this.coords[legId]);
          this.gatherCircles(legId, circle, circlesPayload);
        }
        
        this.validateAndDispatchMovementCircles(circlesPayload);
      }

    }
    window.customElements.define(circleGenerator.is, circleGenerator);
  </script>
</dom-module>