<link rel="import" href="../../../../../bower_components/polymer/polymer-element.html">

<dom-module id="movement-watcher">
  <script>
    class movementWatcher extends ReduxMixin(Polymer.Element) {
      static get is() { return 'movement-watcher'; }
      static get properties() {
        return {
          // validate with the current pointers before dispatching
          pointers: {
            statePath: 'movement.pointers'
          },
          // respect current base direction when calculating pointers
          baseDirection: {
            statePath: 'base.direction'
          },
          // flag which allows rotation when moving in one direction
          applyDirectionAndTurnAngles: {
            statePath: 'movement.settings.applyDirectionAndTurnAngles'
          },
          directionJoystick: {
            statePath: 'movement.directionJoystick'
          },
          circles: {
            statePath: 'movement.circles'
          },
          turnJoystick: {
            statePath: 'movement.turnJoystick'
          }
        }
      }
      
      // calc pointers whenever directionJoystick || this.circles || this.turnJoystick || applyDirectionAndTurnAngles changes
      static get observers() {
        return [ 'calcMovementPointers(directionJoystick, circles, turnJoystick, applyDirectionAndTurnAngles)' ];
      }
      
      calcMovementPointers() {
        let payload = {};
        
        for (let legId = 1; legId <= 6; legId++) {
          let currentPointer = {};
          
          switch (GU.getSideFromLegId(legId)) {
            case 'left':
              currentPointer.x = this.circles[legId].x - this.circles[legId].radius * (this.directionJoystick.x / 100); break;
            case 'right':
              currentPointer.x = this.circles[legId].x + this.circles[legId].radius * (this.directionJoystick.x / 100); break;
          }
          currentPointer.y = this.circles[legId].y - this.circles[legId].radius * (this.directionJoystick.y / 100);
          
          if (this.applyDirectionAndTurnAngles)
            // apply baseDirection + turnJoystick
            currentPointer = this.applyDirectionAndTurn(currentPointer, this.circles[legId], this.baseDirection, this.turnJoystick.x, legId);
          
          // check for the same values before dispatching
          this.validateAndGatherPayload(currentPointer, this.pointers, legId, payload);
        }
        
        this.dispatchMovementPointers(payload);
      }
      
      applyDirectionAndTurn(pointer, circle, baseDirection, turn, legId) {
        let dx = pointer.x - circle.x,
            dy = pointer.y - circle.y,
            distance = MU.getDistance(dx, dy),
            circleToPointerAngle = MU.getAngle(dy, dx);
            
        // angle correction
        circleToPointerAngle = GU.correctAngle(circleToPointerAngle);
        
        switch (GU.getSideFromLegId(legId)) {
          case 'left':
            return MU.getCoordsFromDistanceAndAngle(circle.x, circle.y, circleToPointerAngle + baseDirection - turn, distance);
          case 'right':
            return MU.getCoordsFromDistanceAndAngle(circle.x, circle.y, circleToPointerAngle - baseDirection + turn, distance);
        }
      }
      
      validateAndGatherPayload(currentPointer, statePointers, legId, payload) {
        // init state
        if (statePointers[legId] === null) {
          payload[legId] = currentPointer;
          return;
        }
        
        // check if all the values are the same
        if (currentPointer.x === statePointers[legId].x &&
            currentPointer.y === statePointers[legId].y) return;

        // if not then add them to the payload obj
        payload[legId] = payload[legId] || {};
        
        if (statePointers[legId].x !== currentPointer.x) payload[legId].x = currentPointer.x;
        if (statePointers[legId].y !== currentPointer.y) payload[legId].y = currentPointer.y;
      }
      
      dispatchMovementPointers(payload) {
        // prevent dispatching an empty payload object
        if (Object.keys(payload).length === 0) return;
        
        store.dispatch({
          type: "MOVEMENT_POINTERS_CHANGED_BATCHED",
          payload
        });      
      }

    }
    window.customElements.define(movementWatcher.is, movementWatcher);
  </script>
</dom-module>