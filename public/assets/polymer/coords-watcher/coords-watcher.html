<link rel="import" href="../../../../../bower_components/polymer/polymer-element.html">

<dom-module id="coords-watcher">
  <script>
    class coordsWatcher extends ReduxMixin(Polymer.Element) {
      static get is() { return 'coords-watcher'; }
      static get properties() {
        return {
          metaData: {
            statePath: 'metaData'
          },
          angles: {
            statePath: 'angles'
          },
          coords1: {
            statePath: 'coords.1',
            observer: 'observeCoords'
          },
          coords2: {
            statePath: 'coords.2',
            observer: 'observeCoords'
          },
          coords3: {
            statePath: 'coords.3',
            observer: 'observeCoords'
          },
          coords4: {
            statePath: 'coords.4',
            observer: 'observeCoords'
          },
          coords5: {
            statePath: 'coords.5',
            observer: 'observeCoords'
          },
          coords6: {
            statePath: 'coords.6',
            observer: 'observeCoords'
          }
        };
      }
      
      // BEGIN HELPER FUNCTIONS
      
      getDistanceFromBaseToCursor(legId, view) {
        return MU.getDistance(this.getXFromBase(legId, view), this.getYFromBase(legId, view));
      }
      
      getXFromBase(legId, view) {
        return this[`coords${legId}`][`${view}CursorX`] - this[`coords${legId}`][`${view}BaseX`];
      }
      
      getYFromBase(legId, view) {
        return this[`coords${legId}`][`${view}CursorY`] - this[`coords${legId}`][`${view}BaseY`];
      }
      
      getReachDistance(legId, view) {
        return this.getDistanceFromBaseToCursor(legId, view) - this.metaData.combinedLegsLength;
      }
      
      targetWithinReach(legId, view) {
        return this.getReachDistance(legId, view) > 0 ? false : true;
      }

      getAngleFromDistance(legId, view) {
        let screen = MU.getAngle(this.getYFromBase(legId, view), this.getXFromBase(legId, view));
        
        let servo = (screen - 270 < 0) ? screen + 90 : screen - 270;
        
        return { screen, servo: +servo.toFixed(0) };
      }
      
      getSagittalMiscData(legId) {
        // sagittal boundary ball xy
        let sbx = this[`coords${legId}`].sagittalBaseX;
        let sby = this[`coords${legId}`].sagittalBaseY;
        let sagittalWithinReach = this.targetWithinReach(legId, 'sagittal');
        
        // sagittal diff x/y
        let dx = this.getXFromBase(legId, 'sagittal');
        let dy = this.getYFromBase(legId, 'sagittal');
        
        // sagittal distance from sagittal cursor x/y to sagittal base x/y
        let distance = MU.getDistance(dx, dy);
        
        // sagittal straight angle from base to cursor
        let angle = MU.getAngle(dy, dx);
        
        // sagittal misc data
        let sagittalBoundaryBallCoords = MU.getCoordsFromDistanceAndAngle(sbx, sby, angle, this.metaData.combinedLegsLength);
        
        // transverse misc data
        let transverseReachCoords = PU.getTransverseReachCoords(this[`coords${legId}`], this.metaData),
            transverseReachRadius = PU.getTransverseReachRadius(transverseReachCoords),
            transverseLegLength = PU.getTransverseLegLength(sagittalWithinReach, dx, sbx, sagittalBoundaryBallCoords);

        return {
          sagittalDiff: { dx, dy },
          sagittalDistance: distance,
          sagittalAngle: angle,
          sagittalBoundaryBallCoords,
          sagittalWithinReach,
          transverseReachCoords,
          transverseReachRadius,
          transverseLegLength
        };
      }
      
      getTransverseMiscData(legId, angles) {
        // let dx = this.getXFromBase(legId, 'transverse');
        // let dy = this.getYFromBase(legId, 'transverse');
        // let distance = MU.getDistance(dx, dy);
        
        return {
          // transverseDiff: { dx, dy },
          // transverseDistance: distance
        };
      }
      
      getMovementCircleData(transverseReachRadius, legId) {
        let movementCircleDiameter = PU.getMovementCircleDiameter(transverseReachRadius, this.metaData),
            movementCircleRadius = movementCircleDiameter / 2,
            movementCircleCenterCoords = PU.getMovementCenterCoords(this.metaData, this[`coords${legId}`], transverseReachRadius);
        
        return {
          centerX: movementCircleCenterCoords.x,
          centerY: movementCircleCenterCoords.y,
          radius: movementCircleRadius,
          diameter: movementCircleDiameter
        }
      }
      
      dispatchData(legId, angles, misc, movementCircle) {
        let payload = { angles };
        
        if (misc) payload.misc = misc;
        if (movementCircle) payload.movementCircle = movementCircle;
        
        store.dispatch({
          type: "LEG_ANGLE_CHANGED",
          legId: legId,
          payload
        });
      }
      
      // END HELPER FUNCTIONS
      
      // -------------------------------------------------
      
      // BEGIN POSITIONING LOGIC
      
      positionCoxa(legId, view) {
        let coxaCalculated = this.getAngleFromDistance(legId, view);
        
        coxaCalculated.servo = this.validateCoxaOffset(legId, coxaCalculated.servo);
        
        // check if all the values are the same
        if (this.angles[legId].coxaScreenAngle === coxaCalculated.screen &&
            this.angles[legId].coxaServoAngle === coxaCalculated.servo
        ) return;

        // filter out same values
        let angles = {};
        
        if (this.angles[legId].coxaScreenAngle !== coxaCalculated.screen)
          angles.coxaScreenAngle = coxaCalculated.screen;
          
        if (this.angles[legId].coxaServoAngle !== coxaCalculated.servo)
          angles.coxaServoAngle = coxaCalculated.servo;
        
        // let misc = this.getTransverseMiscData(legId, angles);
        this.dispatchData(legId, angles);
      }
      
      positionFemurAndTibia(legId, view) {
        let angles;
        
        if (this.targetWithinReach(legId, view))
          angles = this.calcForWithinReachMode(legId, view);
        else
          angles = this.calcForOutOfReachMode(legId, view);
        
        let misc = this.getSagittalMiscData(legId);
        let movementCircle = this.getMovementCircleData(misc.transverseReachRadius, legId);
        this.dispatchData(legId, angles, misc, movementCircle);
      }
      
      calcForWithinReachMode(legId, view) {
        let femurCalculated = this.getFemurAngle(legId, view);
        let tibiaCalculated = this.getTibiaAngle(legId, view);
        
        // check if all the values are the same
        if (this.angles[legId].femurScreenAngle === femurCalculated.screen &&
            this.angles[legId].femurServoAngle === femurCalculated.servo &&
            this.angles[legId].tibiaScreenAngle === tibiaCalculated.screen &&
            this.angles[legId].tibiaServoAngle === tibiaCalculated.servo
        ) return;
        
        // filter out same values
        let payload = {};
        
        if (this.angles[legId].femurScreenAngle !== femurCalculated.screen)
          payload.femurScreenAngle = femurCalculated.screen;
          
        if (this.angles[legId].femurServoAngle !== femurCalculated.servo)
          payload.femurServoAngle = femurCalculated.servo;
          
        if (this.angles[legId].tibiaScreenAngle !== tibiaCalculated.screen)
          payload.tibiaScreenAngle = tibiaCalculated.screen;
          
        if (this.angles[legId].tibiaServoAngle !== tibiaCalculated.servo)
          payload.tibiaServoAngle = tibiaCalculated.servo;
        
        return payload;
        
        socket.emit('femur-servo-angle-changed', { value: femurCalculated.servo });
        socket.emit('tibia-servo-angle-changed', { value: tibiaCalculated.servo });
      }
      
      calcForOutOfReachMode(legId, view) {
        let angleCalculated = this.getAngleFromDistance(legId, view);
        
        // check if all the values are the same
        if (this.angles[legId].femurScreenAngle === angleCalculated.screen &&
            this.angles[legId].femurServoAngle === angleCalculated.servo &&
            this.angles[legId].tibiaScreenAngle === 0 &&
            this.angles[legId].tibiaServoAngle === 0
        ) return;
        
        // filter out same values
        let payload = {};
        
        if (this.angles[legId].femurScreenAngle !== angleCalculated.screen)
          payload.femurScreenAngle = angleCalculated.screen;
          
        if (this.angles[legId].femurServoAngle !== angleCalculated.servo)
          payload.femurServoAngle = angleCalculated.servo;
          
        if (this.angles[legId].tibiaScreenAngle !== 0)
          payload.tibiaScreenAngle = 0;
          
        if (this.angles[legId].tibiaServoAngle !== 0)
          payload.tibiaServoAngle = 0;
        
        return payload;
        
        socket.emit('femur-servo-angle-changed', { value: angleCalculated.servo });
        socket.emit('tibia-servo-angle-changed', { value: 0 });
      }
      
      getFemurAngle(legId, view) {
        let D1 = Math.atan2(this.getYFromBase(legId, view), this.getXFromBase(legId, view)),
            D2 = MU.lawOfCos(this.getDistanceFromBaseToCursor(legId, view), this.metaData.femurLength, this.metaData.tibiaLength);

        let A1 = D2 - D1;
        
        let A1Screen = A1 / Math.PI * -180,
            A1Servo = A1Screen + 90;
        
        return { screen: A1Screen, servo: +A1Servo.toFixed(0) };
      }
      
      getTibiaAngle(legId, view) {
        let A2 = MU.lawOfCos(this.metaData.femurLength, this.metaData.tibiaLength, this.getDistanceFromBaseToCursor(legId, view));
        
        let A2Screen = 180 - (A2 / Math.PI * 180),
            A2Servo = A2Screen;
        
        return { screen: A2Screen, servo: +A2Servo.toFixed(0) };
      }
      
      validateCoxaOffset(legId, coxaAngle) {
        coxaAngle += this[`coords${legId}`].logicOffsetRotation;
        
        if (coxaAngle < 0) coxaAngle = 360 + coxaAngle;
        else if (coxaAngle > 360) coxaAngle = coxaAngle - 360;
        
        return coxaAngle;
      }
      
      // END POSITIONING LOGIC
      
      // -------------------------------------------------
      
      // BEGIN PROPERTY OBSERVERS

      observeCoords(newValue, oldValue) {
        // first time init... render init values into angles
        if (oldValue === undefined) {
          this.positionFemurAndTibia(newValue.legId, 'sagittal');
          this.positionCoxa(newValue.legId, 'transverse');
          return;
        }

        // sagittal view update
        if (newValue.sagittalCursorX !== oldValue.sagittalCursorX ||
            newValue.sagittalCursorY !== oldValue.sagittalCursorY ||
            newValue.sagittalBaseX !== oldValue.sagittalBaseX ||
            newValue.sagittalBaseY !== oldValue.sagittalBaseY
        ) this.positionFemurAndTibia(newValue.legId, 'sagittal');

        // transverse view update
        if (newValue.transverseCursorX !== oldValue.transverseCursorX ||
            newValue.transverseCursorY !== oldValue.transverseCursorY ||
            newValue.transverseBaseX !== oldValue.transverseBaseX ||
            newValue.transverseBaseY !== oldValue.transverseBaseY
        ) this.positionCoxa(newValue.legId, 'transverse');
      }
      
      // END PROPERTY OBSERVERS
    }

    window.customElements.define(coordsWatcher.is, coordsWatcher);
  </script>
</dom-module>