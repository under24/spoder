<link rel="import" href="../../../../../bower_components/polymer/polymer-element.html">

<dom-module id="movement-handler">
  <script>
    class movementHandler extends ReduxMixin(Polymer.Element) {
      static get is() { return 'movement-handler'; }
      static get properties() {
        return {
          enabled: {
            statePath: 'movement.settings.generatorEnabled',
            observer: 'observeEnabled'
          },
          gaits: {
            statePath: 'gaits'
          },
          loop: {
            statePath: 'movement.settings.loop'
          },
          iteration: {
            statePath: 'movement.iteration'
          }
        };
      }
      
      runGenerator(tick = 1) {
        // prevent multiple invocation
        if (this.generatorInterval) {
          console.warn('Movement generator is already in progress');
          return;
        }
        
        // validation
        if (tick > this.iteration.amountOfTicks) {
          console.warn('Specified tick is bigger that the amount in the iteration');
          return;
        }
        
        // iteration starts after (1000 / this.iteration.tps) amount of time with tick 1
        this.generatorInterval = setInterval(() => {
          // generate tick value
          let payload = this.generateTickPayload(tick);
          
          // dispatch tick data
          store.dispatch({
            type: "SEQUENCE_SHIFTED_XY_BATCHED",
            payload: payload.stepValues,
            currentTick: tick,
            currentTickPct: payload.currentTickPct
          });
          
          // check if that was the last tick
          if (tick === this.iteration.amountOfTicks) {
            // finish current iteration
            this.clearGeneratorInterval();
            
            // reset progress when the iteration is complete
            store.dispatch({
              type: "MOVEMENT_ITERATION_VALUES_CHANGED",
              payload: { currentTick: 0, currentTickPct: 0 }
            });
            
            // start iterating over again
            if (this.loop)
              this.runGenerator();
            // set generatorEnabled to false (disable movement generator)
            else
              store.dispatch({
                type: "MOVEMENT_SETTINGS_CHANGED",
                payload: { generatorEnabled: false }
              });
          }
          
          // update tick value for the next tick interval
          tick++;
          
        }, 1000 / this.iteration.tps);
        
      }
      
      clearGeneratorInterval() {
        clearInterval(this.generatorInterval);
        this.generatorInterval = undefined;
      }
      
      pauseGenerator() {
        this.clearGeneratorInterval();
      }
      
      runOrResumeGenerator() {
        this.runGenerator(this.iteration.currentTick + 1);
      }
      
      generateTickPayload(tick) {
        let amountOfTicks = this.iteration.amountOfTicks,
            // this tick's pct of the current iteration
            currentTickPct = this.calcTickPct(tick, amountOfTicks),
            // legs which are used in the current stroke of the iteration
            legsUsedInCurrentStroke = this.getLegsUsedInCurrentStroke(tick),
            // full iteration movement data
            iterationMovementData = this.iteration.blueprint,
            // payload values (current tick/step values for dispatching)
            stepValues = {};
            
        for (let legId = 1; legId <= 6; legId++) {
          stepValues[legId] = this.calcIterationStepValues(legId, legsUsedInCurrentStroke, amountOfTicks, iterationMovementData);
        }
        
        return { stepValues, currentTickPct };
      }
      
      calcTickPct(tick, amountOfTicks) {
        return MU.roundNumber(100 / amountOfTicks * tick, 1);
      }
      
      getLegsUsedInCurrentStroke(currentTick) {
        let sequence = this.gaits[this.iteration.gait].sequence,
            strokeTickMap = this.iteration.strokeTickMap;
        
        // find current legs based on the stroke tick map (for the current iteration)
        for (let i = 0; i < strokeTickMap.length; i++) {
          if (currentTick >= strokeTickMap[i].startTick &&
              currentTick <= strokeTickMap[i].endTick)
            return sequence[i];
        }
        
        // not found. must be an error. it should always be found
        return null;
      }
      
      calcIterationStepValues(legId, legsUsedInCurrentStroke, amountOfTicks, iterationMovementData) {
        // base stroke pct
        let baseStrokePcts = { startPct: 0, endPct: 100 };
        
        // create a return object and assign baseXY values
        let result = {
          transverseBaseX: this.calcTickValue(amountOfTicks, iterationMovementData[legId].transverseBaseX, baseStrokePcts),
          transverseBaseY: this.calcTickValue(amountOfTicks, iterationMovementData[legId].transverseBaseY, baseStrokePcts),
        };
        
        // if legId is one of the currently used legs then add cursor data to the return object
        if (~legsUsedInCurrentStroke.indexOf(legId)) {
          // cursor stroke pct
          let cursorStrokePcts = this.gaits[this.iteration.gait].legTimings[legId];
          
          result.transverseCursorX = this.calcTickValue(amountOfTicks, iterationMovementData[legId].transverseCursorX, cursorStrokePcts);
          result.transverseCursorY = this.calcTickValue(amountOfTicks, iterationMovementData[legId].transverseCursorY, cursorStrokePcts);
        };
        
        return result;
      }
      
      calcTickValue(amountOfTicks, pixelsToMove, strokePcts) {
        let startTick = this.getClosestTick(strokePcts.startPct, amountOfTicks) + 1, // because it starts from the next tick
            endTick = this.getClosestTick(strokePcts.endPct, amountOfTicks),
            ticksBetweenStartAndEnd = this.getAmountOfTicksBetween(startTick, endTick),
            tickValue = this.calcTickValueBasedOnPxlsToMove(ticksBetweenStartAndEnd, pixelsToMove);
            
        return tickValue;
      }
      
      getClosestTick(pct, amountOfTicks) {
        let currentNumber = 0;
        
        let diff = pct;
        for (let tick = 1; tick <= amountOfTicks; tick++) {
          let tickPct = this.calcTickPct(tick, amountOfTicks);
          
          let newDiff = Math.abs(pct - tickPct);
          if (newDiff < diff) {
            diff = newDiff;
            currentNumber = tick;
          }
        }
        return +currentNumber;
      }
      
      getAmountOfTicksBetween(startTick, endTick) {
        return (endTick - startTick) + 1;
      }
      
      calcTickValueBasedOnPxlsToMove(amountOfTicks, pixelsToMove) {
        return pixelsToMove / amountOfTicks;
      }
      
      observeEnabled(newValue, oldValue) {
        // movement enabled
        if (newValue === true)
          this.runOrResumeGenerator();
        // movement disabled
        else
          this.pauseGenerator();
      }

    }
    window.customElements.define(movementHandler.is, movementHandler);
  </script>
</dom-module>