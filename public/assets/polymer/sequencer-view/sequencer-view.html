<link rel="import" href="../../../../../bower_components/polymer/polymer-element.html">

<dom-module id="sequencer-view">
  <template>
    <style>
      :host {
        display: block;
        width: 100%;
        height: 100%;
        position: relative;
      }
      #sequenceTimeline {
        width: 95%;
        border: 1px dotted;
        margin: auto;
        box-sizing: border-box;
        position: relative;
        display: flex;
        flex-direction: column;
      }
      #sequenceTimeline .leg-sequence {
        font-size: 17px;
        display: flex;
        border-top: 1px dotted;
      }
      #sequenceTimeline .leg-sequence:first-child {
        border-top: none;
      }
      #sequenceTimeline .sequence-header {
        display: inline-block;
        border-right: 1px dotted;
        padding: 4px 0px 4px 8px;
        width: 48px;
        font-size: 16px;
      }
      #sequenceTimeline #cursor {
        width: 1px;
        background: black;
        position: absolute;
        display: inline-block;
        top: 0px;
        bottom: 0px;
      }
      #cursorKnob {
        position: absolute;
        top: 100%;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(128, 128, 128, 0.2);
        padding: 4px 8px 2px;
      }
      .sequence-content {
        flex: 1;
        position: relative;
      }
      .sequence-content .payload {
        position: absolute;
        background-color: rgba(0, 0, 0, 0.1);
        top: 0px;
        bottom: 0px;
        text-align: center;
        line-height: 26px;
      }
      .cursor-wrapper {
        position: absolute;
        top: 0px;
        bottom: 0px;
        left: 57px;
        right: 0px;
      }
      fieldset {
        width: 95%;
        box-sizing: border-box;
        margin: 0px auto 10px auto;
        border-width: 1px;
      }
    </style>
    
    <label>
      <input type="checkbox" checked={{loop::click}} />
      Loop sequence
    </label>

    <br /><br /><br />
    
    <div id="sequenceTimeline">
      <!-- <div class="leg-sequence" id="leg1">
        <div class="sequence-header">Base</div>
        <div class="sequence-content">
          <div class="payload">25</div>
          <div class="payload">25</div>
          <div class="payload">25</div>
          <div class="payload">25</div>
        </div>
      </div>
      <hr /> -->
      <div class="leg-sequence" id="leg1">
        <div class="sequence-header">L1 (1)</div>
        <div class="sequence-content">
          <div class="payload" style$="[[computeBlueprintMetaData(blueprintMetaData,'1')]]">[[computeBlueprintPayloadPeriod('1', blueprint)]]</div>
        </div>
      </div>
      <div class="leg-sequence" id="leg2">
        <div class="sequence-header">R1 (2)</div>
        <div class="sequence-content">
          <div class="payload" style$="[[computeBlueprintMetaData(blueprintMetaData,'2')]]">[[computeBlueprintPayloadPeriod('2', blueprint)]]</div>
        </div>
      </div>
      <div class="leg-sequence" id="leg3">
        <div class="sequence-header">L2 (3)</div>
        <div class="sequence-content">
          <div class="payload" style$="[[computeBlueprintMetaData(blueprintMetaData,'3')]]">[[computeBlueprintPayloadPeriod('3', blueprint)]]</div>
        </div>
      </div>
      <div class="leg-sequence" id="leg4">
        <div class="sequence-header">R2 (4)</div>
        <div class="sequence-content">
          <div class="payload" style$="[[computeBlueprintMetaData(blueprintMetaData,'4')]]">[[computeBlueprintPayloadPeriod('4', blueprint)]]</div>
        </div>
      </div>
      <div class="leg-sequence" id="leg5">
        <div class="sequence-header">L3 (5)</div>
        <div class="sequence-content">
          <div class="payload" style$="[[computeBlueprintMetaData(blueprintMetaData,'5')]]">[[computeBlueprintPayloadPeriod('5', blueprint)]]</div>
        </div>
      </div>
      <div class="leg-sequence" id="leg6">
        <div class="sequence-header">R3 (6)</div>
        <div class="sequence-content">
          <div class="payload" style$="[[computeBlueprintMetaData(blueprintMetaData,'6')]]">[[computeBlueprintPayloadPeriod('6', blueprint)]]</div>
        </div>
      </div>
      
      <div class="cursor-wrapper">
        <div id="cursor" style$="left: [[sequenceProgress.pct]]%">
          <div id="cursorKnob">[[sequenceProgress.pct]]</div>
        </div>
      </div>

    </div>
    
    <br /><br />
    <fieldset>
      <legend>Blueprint</legend>
      <button type="button" on-click="onGenerateBlueprintButtonClicked">Generate Blueprint</button>
    </fieldset>
    <fieldset>
      <legend>Sequence</legend>
      <button type="button" on-click="onGenerateSequenceButtonClicked">Generate Sequence</button>
    </fieldset>
    <fieldset>
      <legend>Player</legend>
      <button type="button" on-click="playOrResumeSequence">Play / Resume</button>
      <button type="button" on-click="pauseSequence">Pause</button>
    </fieldset>
    
    
  </template>

  <script>
    class sequencerView extends ReduxMixin(Polymer.Element) {
      static get is() { return 'sequencer-view'; }
      static get properties() {
        return {
          baseCenterCoords: {
            statePath: 'base.centerCoords'
          },
          pointers: {
            statePath: 'movement.pointers',
            observer: 'observePointers'
          },
          circles: {
            statePath: 'movement.circles'
          },
          coords: {
            statePath: 'coords'
          },
          directionJoystick: {
            statePath: 'movement.directionJoystick'
          },
          turnJoystick: {
            statePath: 'movement.turnJoystick'
          },
          gaits: {
            statePath: 'gaits'
          },
          sequenceProgress: {
            statePath: 'movement.sequenceProgress'
          },
          loop: {
            value: true,
            // statePath: 'movement.settings.loop'
          }
        };
      }
      
      generateSequenceBlueprint() {
        let blueprint = {},
            metaData = {};
        
        for (let legId = 1; legId <= 6; legId++) {
          let pointerToCursorX = this.coords[legId].transverseCursorX - this.pointers[legId].x,
              pointerToCursorY = this.coords[legId].transverseCursorY - this.pointers[legId].y,

              pointerToCircleCenterX = this.circles[legId].x - this.pointers[legId].x,
              pointerToCircleCenterY = this.circles[legId].y - this.pointers[legId].y;

          metaData[legId] = BU.getStartAndEndPctBasedOnLegId(legId, this.gaits, 'ripple');

          blueprint[legId] = [
            {
              "coordType": "transverseBaseX",
              "startPct": 0,
              "endPct": 100,
              "pxlsToMove": pointerToCircleCenterX
            },
            {
              "coordType": "transverseBaseY",
              "startPct": 0,
              "endPct": 100,
              "pxlsToMove": pointerToCircleCenterY
            },
            {
              "coordType": "transverseCursorX",
              "startPct": metaData[legId].startPct,
              "endPct": metaData[legId].endPct,
              "pxlsToMove": pointerToCursorX
            },
            {
              "coordType": "transverseCursorY",
              "startPct": metaData[legId].startPct,
              "endPct": metaData[legId].endPct,
              "pxlsToMove": pointerToCursorY
            }
          ];
        }
        
        return { blueprint, metaData };
      }
      
      computeBlueprintMetaData(blueprintMetaData ,legId) {
        return `left: ${blueprintMetaData[legId].startPct}%; width: ${blueprintMetaData[legId].endPct - blueprintMetaData[legId].startPct}%`
      }
      
      computeBlueprintPayloadPeriod(legId) {
        let dx = this.coords[legId].transverseCursorX - this.pointers[legId].x,
            dy = this.coords[legId].transverseCursorY - this.pointers[legId].y,
            dist = MU.getDistance(dx, dy).toFixed(2);
        
        return dist;
      }
      
      onGenerateBlueprintButtonClicked() {
        let result = this.generateSequenceBlueprint();
        this.blueprint = result.blueprint;
        this.blueprintMetaData = result.metaData;
      }
      
      onGenerateSequenceButtonClicked() {
        this.sequence = SU.generateSequenceTimeline(this.blueprint, 60, 750);
      }
      
      pauseSequence() {
        this.clearSequenceInterval();
      }
      
      clearSequenceInterval() {
        clearInterval(this.sequenceInterval);
        this.sequenceInterval = undefined;
      }
      
      playOrResumeSequence() {
        this.runSequence(this.sequenceProgress.tick + 1);
      }
      
      observePointers() {
        if (this.directionJoystick !== undefined && this.prevDirectionJoystick !== this.directionJoystick) {
          this.prevDirectionJoystick = this.directionJoystick;
          this.loadSequence();
        }
        else if (this.turnJoystick !== undefined && this.prevTurnJoystick !== this.turnJoystick) {
          this.prevTurnJoystick = this.turnJoystick;
          this.loadSequence();
        }
      }
      
      loadSequence() {
        this.onGenerateBlueprintButtonClicked();
        this.onGenerateSequenceButtonClicked();
      }
      
      runSequence(tick = 1) {
        // prevent multiple invocation
        if (this.sequenceInterval) {
          console.warn('another sequence is in progress');
          return;
        }
        
        this.sequenceInterval = setInterval(() => {
          
          // apply movement.turnJoystick values
          if (this.turnJoystick.x) {
            // angle / amount of ticks = angle for each tick
            let stepAngle = this.turnJoystick.x / this.sequence.metaData.amountOfTicks;
            
            for (let legId = 1; legId <= 6; legId++) {
              // find rotated base coords
              let rotatedCoords = RU.getRotatedCoords(this.baseCenterCoords, MU.flipNumber(stepAngle), this.coords[legId]);
              // get shift values from actual coords
              let shiftX = this.coords[legId].transverseBaseX - rotatedCoords.x,
                  shiftY = this.coords[legId].transverseBaseY - rotatedCoords.y;
              // add turn values to the payload
              this.sequence.timeline[tick].payload[legId].transverseBaseX += shiftX;
              this.sequence.timeline[tick].payload[legId].transverseBaseY += shiftY;
            }
          }
          
          store.dispatch({
            type: "SEQUENCE_SHIFTED_XY_BATCHED",
            payload: this.sequence.timeline[tick].payload,
            pct: this.sequence.timeline[tick].pct,
            tick
          });
          
          // sequence complete
          if (tick >= this.sequence.metaData.amountOfTicks) {
            this.clearSequenceInterval();

            // reset sequenceProgress to 0
            store.dispatch({
              type: "SEQUENCE_PROGRESS_PCT_CHANGED",
              pct: 0,
              tick: 0
            });
            
            // if loop === true, create a new sequence and run it
            if (this.loop) {
              this.loadSequence();
              this.runSequence();
            }
          }
          
          // update next tick value
          tick++;
          
        }, 1000 / this.sequence.metaData.tps);
      }

    }
    window.customElements.define(sequencerView.is, sequencerView);
  </script>
</dom-module>