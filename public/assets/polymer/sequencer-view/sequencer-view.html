<link rel="import" href="../../../../../bower_components/polymer/polymer-element.html">

<dom-module id="sequencer-view">
  <template>
    <style>
      :host {
        display: block;
        width: 100%;
        height: 100%;
        position: relative;
      }
      #sequenceTimeline {
        width: 95%;
        border: 1px solid;
        margin: auto;
        box-sizing: border-box;
        position: relative;
        display: flex;
        flex-direction: column;
      }
      #sequenceTimeline .leg-sequence {
        font-size: 17px;
        display: flex;
      }
      #sequenceTimeline hr {
        margin: 0px;
        border-bottom: none;
        border-left: none;
        border-right: none;
      }
      #sequenceTimeline .sequence-header {
        display: inline-block;
        border-right: 1px solid;
        padding: 4px 0px 4px 8px;
        width: 50px;
      }
      #sequenceTimeline #cursor {
        width: 1px;
        background: black;
        position: absolute;
        display: inline-block;
        top: 0px;
        bottom: 0px;
      }
      #sequenceTimeline #cursor::after {
        content: '';
        display: inline-block;
        width: 10px;
        background-color: rgba(0, 0, 0, 0.05);
        top: 0px;
        bottom: 0px;
        position: absolute;
        left: 50%;
        transform: translateX(-50%);
      }
      #cursorKnob {
        position: absolute;
        top: 100%;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(128, 128, 128, 0.21);
        padding: 4px 8px 2px;
      }
      .sequence-content {
        flex: 1;
        position: relative;
      }
      .sequence-content .payload {
        position: absolute;
        background-color: rgba(0, 0, 0, 0.2);
        top: 3px;
        bottom: 3px;
        text-align: center;
        line-height: 22px;
      }
      .cursor-wrapper {
        position: absolute;
        top: 0px;
        bottom: 0px;
        left: 59px;
        right: 0px;
      }
      fieldset {
        width: 95%;
        box-sizing: border-box;
        margin: 0px auto 10px auto;
        border-width: 1px;
      }
    </style>
    
    <label>
      <input type="checkbox" checked={{loop::click}} />
      Loop sequence
    </label>

    <br /><br /><br />
    
    <div id="sequenceTimeline">
      <!-- <div class="leg-sequence" id="leg1">
        <div class="sequence-header">Base</div>
        <div class="sequence-content">
          <div class="payload">25</div>
          <div class="payload">25</div>
          <div class="payload">25</div>
          <div class="payload">25</div>
        </div>
      </div>
      <hr /> -->
      <div class="leg-sequence" id="leg1">
        <div class="sequence-header">L1 (1)</div>
        <div class="sequence-content">
          <div class="payload" style$="[[computeBlueprintMetaData(blueprintMetaData,'1')]]">[[computeBlueprintPayloadPeriod('1', blueprint)]]</div>
        </div>
      </div>
      <hr />
      <div class="leg-sequence" id="leg2">
        <div class="sequence-header">R1 (2)</div>
        <div class="sequence-content">
          <div class="payload" style$="[[computeBlueprintMetaData(blueprintMetaData,'2')]]">[[computeBlueprintPayloadPeriod('2', blueprint)]]</div>
        </div>
      </div>
      <hr />
      <div class="leg-sequence" id="leg3">
        <div class="sequence-header">L2 (3)</div>
        <div class="sequence-content">
          <div class="payload" style$="[[computeBlueprintMetaData(blueprintMetaData,'3')]]">[[computeBlueprintPayloadPeriod('3', blueprint)]]</div>
        </div>
      </div>
      <hr />
      <div class="leg-sequence" id="leg4">
        <div class="sequence-header">R2 (4)</div>
        <div class="sequence-content">
          <div class="payload" style$="[[computeBlueprintMetaData(blueprintMetaData,'4')]]">[[computeBlueprintPayloadPeriod('4', blueprint)]]</div>
        </div>
      </div>
      <hr />
      <div class="leg-sequence" id="leg5">
        <div class="sequence-header">L3 (5)</div>
        <div class="sequence-content">
          <div class="payload" style$="[[computeBlueprintMetaData(blueprintMetaData,'5')]]">[[computeBlueprintPayloadPeriod('5', blueprint)]]</div>
        </div>
      </div>
      <hr />
      <div class="leg-sequence" id="leg6">
        <div class="sequence-header">R3 (6)</div>
        <div class="sequence-content">
          <div class="payload" style$="[[computeBlueprintMetaData(blueprintMetaData,'6')]]">[[computeBlueprintPayloadPeriod('6', blueprint)]]</div>
        </div>
      </div>
      
      <div class="cursor-wrapper">
        <div id="cursor" style$="left: [[sequenceProgress.pct]]%">
          <div id="cursorKnob">[[sequenceProgress.pct]]</div>
        </div>
      </div>

    </div>
    
    <br /><br />
    <fieldset>
      <legend>Blueprint</legend>
      <button type="button" on-click="onGenerateBlueprintButtonClicked">Generate Blueprint</button>
    </fieldset>
    <fieldset>
      <legend>Sequence</legend>
      <button type="button" on-click="onGenerateSequenceButtonClicked">Generate Sequence</button>
    </fieldset>
    <fieldset>
      <legend>Player</legend>
      <button type="button" on-click="playOrResumeSequence">Play / Resume</button>
      <button type="button" on-click="pauseSequence">Pause</button>
    </fieldset>
    
    
  </template>

  <script>
    class sequencerView extends ReduxMixin(Polymer.Element) {
      static get is() { return 'sequencer-view'; }
      static get properties() {
        return {
          pointers: {
            statePath: 'movement.pointers',
            observer: 'observePointers'
          },
          joystick: {
            statePath: 'movement.joystick'
          },
          circles: {
            statePath: 'movement.circles'
          },
          coords: {
            statePath: 'coords'
          },
          gaits: {
            statePath: 'gaits'
          },
          sequenceProgress: {
            statePath: 'movement.sequenceProgress'
          },
          loop: {
            value: true,
            // statePath: 'movement.sequenceMetaData.loop'
          }
        };
      }
      
      generateSequenceBlueprint() {
        let blueprint = {},
            metaData = {};
        
        for (let i = 1; i <= 6; i++) {
          let pointerToCursorX = this.coords[i].transverseCursorX - this.pointers[i].x,
              pointerToCursorY = this.coords[i].transverseCursorY - this.pointers[i].y,

              pointerToCircleCenterX = this.circles[i].centerX - this.pointers[i].x,
              pointerToCircleCenterY = this.circles[i].centerY - this.pointers[i].y;

              metaData[i] = BU.getStartAndEndPctBasedOnLegId(i, this.gaits, 'ripple');

          blueprint[i] = [
            {
              "coordType": "transverseBaseX",
              "startPct": 0,
              "endPct": 100,
              "pxlsToMove": pointerToCircleCenterX
            },
            {
              "coordType": "transverseBaseY",
              "startPct": 0,
              "endPct": 100,
              "pxlsToMove": pointerToCircleCenterY
            },
            {
              "coordType": "transverseCursorX",
              "startPct": metaData[i].startPct,
              "endPct": metaData[i].endPct,
              "pxlsToMove": pointerToCursorX
            },
            {
              "coordType": "transverseCursorY",
              "startPct": metaData[i].startPct,
              "endPct": metaData[i].endPct,
              "pxlsToMove": pointerToCursorY
            }
          ];
        }
        
        return { blueprint, metaData };
      }
      
      // modifyBlueprint() {
      //   let blueprint = {},
      //       metaData = {},
      //       lastSequenceValues = this.sequenceProgress,
      //       currentGaitIndex = BU.getLegIdFromMidPct(lastSequenceValues.pct);
      //       
      //   for (; currentGaitIndex < this.gaits.ripple.length; currentGaitIndex++) {
      //     
      //     this.gaits.ripple[currentGaitIndex].forEach((legId) => {
      //       
      //       debugger;
      //       
      //       let pointerToCursorX = this.coords[legId].transverseCursorX - this.pointers[legId].x,
      //           pointerToCursorY = this.coords[legId].transverseCursorY - this.pointers[legId].y,
      // 
      //           pointerToCircleCenterX = this.circles[legId].centerX - this.pointers[legId].x,
      //           pointerToCircleCenterY = this.circles[legId].centerY - this.pointers[legId].y,
      //           iteratedGaitIndex = BU.getGaitIndexFromLegId(6, this.gaits, 'ripple');
      // 
      //           metaData[legId] = BU.getStartAndEndPctBasedOnLegId(legId, this.gaits, 'ripple');
      //           
      //       
      //       if (currentGaitIndex === iteratedGaitIndex) metaData[legId].startPct = lastSequenceValues.pct;
      //           
      //       blueprint[legId] = [
      //         {
      //           coordType: "transverseBaseX",
      //           startPct: 0,
      //           endPct: 0,
      //           pxlsToMove: pointerToCircleCenterX
      //         },
      //         {
      //           coordType: "transverseBaseY",
      //           startPct: 0,
      //           endPct: 100,
      //           pxlsToMove: pointerToCircleCenterY
      //         },
      //         {
      //           coordType: "transverseCursorX",
      //           startPct: metaData[legId].startPct,
      //           endPct: metaData[legId].endPct,
      //           pxlsToMove: pointerToCursorX
      //         },
      //         {
      //           coordType: "transverseCursorY",
      //           startPct: metaData[legId].startPct,
      //           endPct: metaData[legId].endPct,
      //           pxlsToMove: pointerToCursorY
      //         }
      //       ]
      //     })
      //   }
      //   
      //   return { blueprint, metaData };
      // }
      
      computeBlueprintMetaData(blueprintMetaData ,legId) {
        return `left: ${blueprintMetaData[legId].startPct}%; width: ${blueprintMetaData[legId].endPct - blueprintMetaData[legId].startPct}%`
      }
      
      computeBlueprintPayloadPeriod(legId) {
        let dx = this.coords[legId].transverseCursorX - this.pointers[legId].x,
            dy = this.coords[legId].transverseCursorY - this.pointers[legId].y,
            dist = MU.getDistance(dx, dy).toFixed(2);
        
        return dist;
      }
      
      onGenerateBlueprintButtonClicked() {
        let result = this.generateSequenceBlueprint();
        this.blueprint = result.blueprint;
        this.blueprintMetaData = result.metaData;
      }
      
      onGenerateSequenceButtonClicked() {
        this.sequence = SU.generateSequenceTimeline(this.blueprint, 60, 750);
      }
      
      pauseSequence() {
        this.clearSequenceInterval();
      }
      
      clearSequenceInterval() {
        clearInterval(this.sequenceInterval);
        this.sequenceInterval = undefined;
      }
      
      playOrResumeSequence() {
        this.runSequence(this.sequenceProgress.tick + 1);
      }
      
      observePointers() {
        if (this.joystick === undefined || this.prevJoystickObj === this.joystick) return;

        this.prevJoystickObj = this.joystick;
        this.loadSequence();
      }
      
      loadSequence() {
        this.onGenerateBlueprintButtonClicked();
        this.onGenerateSequenceButtonClicked();
      }
      
      runSequence(tick = 1) {
        // prevent multiple invokation
        if (this.sequenceInterval) {
          console.warn('sequence is already running');
          return;
        } 
        
        this.sequenceInterval = setInterval(() => {
          
          store.dispatch({
            type: "SEQUENCE_SHIFTED_XY_BATCHED",
            payload: this.sequence.timeline[tick].payload,
            pct: this.sequence.timeline[tick].pct,
            tick
          });
          
          // sequence iteration complete
          if (tick >= this.sequence.metaData.amountOfTicks) {
            this.clearSequenceInterval();

            // reset sequenceProgress to 0
            store.dispatch({
              type: "SEQUENCE_PROGRESS_PCT_CHANGED",
              pct: 0,
              tick: 0
            });
            
            if (this.loop) {
              this.loadSequence();
              this.runSequence();
            }
          }
          
          // update next tick value
          tick++;
          
        }, 1000 / this.sequence.metaData.tps);
      }

    }
    window.customElements.define(sequencerView.is, sequencerView);
  </script>
</dom-module>