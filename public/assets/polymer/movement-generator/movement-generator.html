<link rel="import" href="../../../../../bower_components/polymer/polymer-element.html">

<dom-module id="movement-generator">
  <template>
    <style>
      :host {
        display: block;
        width: 100%;
        height: 100%;
        position: relative;
      }
      #sequenceTimeline {
        width: 95%;
        border: 1px dotted;
        margin: auto;
        box-sizing: border-box;
        position: relative;
        display: flex;
        flex-direction: column;
      }
      #sequenceTimeline .leg-sequence {
        font-size: 17px;
        display: flex;
        border-top: 1px dotted;
      }
      #sequenceTimeline .leg-sequence:first-child {
        border-top: none;
      }
      #sequenceTimeline .sequence-header {
        display: inline-block;
        border-right: 1px dotted;
        padding: 4px 0px 4px 8px;
        width: 48px;
        font-size: 16px;
      }
      #sequenceTimeline #cursor {
        width: 1px;
        background: black;
        position: absolute;
        display: inline-block;
        top: 0px;
        bottom: 0px;
      }
      #cursorKnob {
        position: absolute;
        top: 100%;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(128, 128, 128, 0.2);
        padding: 4px 8px 2px;
      }
      .sequence-content {
        flex: 1;
        position: relative;
      }
      .sequence-content .payload {
        position: absolute;
        background-color: rgba(0, 0, 0, 0.1);
        top: 0px;
        bottom: 0px;
        text-align: center;
        line-height: 26px;
      }
      .cursor-wrapper {
        position: absolute;
        top: 0px;
        bottom: 0px;
        left: 57px;
        right: 0px;
      }
      fieldset {
        width: 95%;
        box-sizing: border-box;
        margin: 0px auto 10px auto;
        border-width: 1px;
      }
    </style> 

    <br /><br /><br />
    
    <div id="sequenceTimeline">
      <!-- <div class="leg-sequence" id="leg1">
        <div class="sequence-header">Base</div>
        <div class="sequence-content">
          <div class="payload">25</div>
          <div class="payload">25</div>
          <div class="payload">25</div>
          <div class="payload">25</div>
        </div>
      </div>
      <hr /> -->
      <div class="leg-sequence" id="leg1">
        <div class="sequence-header">L1 (1)</div>
        <div class="sequence-content">
          <div class="payload" style$="[[computeStrokeTiming('1', iteration.gait)]]">[[computeStrokeDistance('1', iterationMovementData)]]</div>
        </div>
      </div>
      <div class="leg-sequence" id="leg2">
        <div class="sequence-header">R1 (2)</div>
        <div class="sequence-content">
          <div class="payload" style$="[[computeStrokeTiming('2', iteration.gait)]]">[[computeStrokeDistance('2', iterationMovementData)]]</div>
        </div>
      </div>
      <div class="leg-sequence" id="leg3">
        <div class="sequence-header">L2 (3)</div>
        <div class="sequence-content">
          <div class="payload" style$="[[computeStrokeTiming('3', iteration.gait)]]">[[computeStrokeDistance('3', iterationMovementData)]]</div>
        </div>
      </div>
      <div class="leg-sequence" id="leg4">
        <div class="sequence-header">R2 (4)</div>
        <div class="sequence-content">
          <div class="payload" style$="[[computeStrokeTiming('4', iteration.gait)]]">[[computeStrokeDistance('4', iterationMovementData)]]</div>
        </div>
      </div>
      <div class="leg-sequence" id="leg5">
        <div class="sequence-header">L3 (5)</div>
        <div class="sequence-content">
          <div class="payload" style$="[[computeStrokeTiming('5', iteration.gait)]]">[[computeStrokeDistance('5', iterationMovementData)]]</div>
        </div>
      </div>
      <div class="leg-sequence" id="leg6">
        <div class="sequence-header">R3 (6)</div>
        <div class="sequence-content">
          <div class="payload" style$="[[computeStrokeTiming('6', iteration.gait)]]">[[computeStrokeDistance('6', iterationMovementData)]]</div>
        </div>
      </div>
      
      <div class="cursor-wrapper">
        <div id="cursor" style$="left: [[iteration.currentTickPct]]%">
          <div id="cursorKnob">[[iteration.currentTickPct]]</div>
        </div>
      </div>

    </div>
    
    <br /><br />
    
    <fieldset>
      <legend>Movement settings:</legend>
      <p>
        <label>
          <input type="checkbox" checked={{loop::click}} />
          Loop generator
        </label>
      </p>
      <p>TPS: [[iteration.tps]]</p>
      <p>Iteration Duration: [[iteration.duration]]</p>
    </fieldset>

  </template>

  <script>
    class movementGenerator extends ReduxMixin(Polymer.Element) {
      static get is() { return 'movement-generator'; }
      static get properties() {
        return {
          // baseCenterCoords: {
          //   statePath: 'base.centerCoords'
          // },
          circles: {
            statePath: 'movement.circles'
          },
          coords: {
            statePath: 'coords'
          },
          // directionJoystick: {
          //   statePath: 'movement.directionJoystick'
          // },
          // turnJoystick: {
          //   statePath: 'movement.turnJoystick'
          // },
          gaits: {
            statePath: 'gaits'
          },
          iteration: {
            statePath: 'movement.iteration'
          },
          loop: {
            statePath: 'movement.settings.loop'
          },
          iterationMovementData: {
            
          },
          pointers: {
            statePath: 'movement.pointers'
          }
        };
      }
      
      getNextTickValues(tick) {
        let amountOfTicks = this.iteration.amountOfTicks,
            // this tick's pct of the current iteration`
            currentTickPct = this.getTickPct(tick, amountOfTicks),
            // legs which are used in the current stroke of the iteration
            legsUsedInCurrentStroke = this.getLegsUsedInCurrentStroke(currentTickPct),
            // full iteration movement data
            iterationMovementData = {},
            // iteration next tick values (step values)
            stepValues = {};
        
        for (let legId = 1; legId <= 6; legId++) {
          iterationMovementData[legId] = this.getIterationMovementData(legId);
          stepValues[legId] = this.getIterationStepValues(legId, legsUsedInCurrentStroke, amountOfTicks, iterationMovementData);
        }
        
        return {
          tickValues: stepValues, 
          currentTickPct 
        };
        
        // performance: ui after calculations
        this.iterationMovementData = iterationMovementData;
      }
      
      getIterationMovementData(legId) {
        return {
          transverseBaseX: this.circles[legId].x - this.pointers[legId].x,
          transverseBaseY: this.circles[legId].y - this.pointers[legId].y,
          transverseCursorX: this.coords[legId].transverseCursorX - this.pointers[legId].x,
          transverseCursorY: this.coords[legId].transverseCursorY - this.pointers[legId].y
        };
      }
      
      getIterationStepValues(legId, legsUsedInCurrentStroke, amountOfTicks, iterationMovementData) {
        // cache stroke data
        // base
        let baseStroke = { startPct: 0, endPct: 100 };
        
        // create a return object and assign baseXY values  
        let result = {
          transverseBaseX: this.getTickValue(amountOfTicks, iterationMovementData[legId].transverseBaseX, baseStroke),
          transverseBaseY: this.getTickValue(amountOfTicks, iterationMovementData[legId].transverseBaseY, baseStroke),
        };
        
        // if legId is one of the currently used legs 
        // then add cursor data to the return object
        if (~legsUsedInCurrentStroke.indexOf(legId)) {
          // cursors
          let stroke = this.gaits[this.iteration.gait].legTimings[legId];
          
          result.transverseCursorX = this.getTickValue(amountOfTicks, iterationMovementData[legId].transverseCursorX, stroke);
          result.transverseCursorY = this.getTickValue(amountOfTicks, iterationMovementData[legId].transverseCursorY, stroke);
        };
        
        return result;
      }
      
      getTickValue(amountOfTicks, pixelsToMove, stroke) {
        let startTick = this.getClosestTick(stroke.startPct, amountOfTicks) + 1, // because it starts from the next tick
            endTick = this.getClosestTick(stroke.endPct, amountOfTicks),
            ticksBetweenStartAndEnd = this.getAmountOfTicksBetween(startTick, endTick),
            tickValue = this.getTickValueBasedOnPxlsToMove(ticksBetweenStartAndEnd, pixelsToMove);
            
        return tickValue;
      }
      
      getAmountOfTicksBetween(startTick, endTick) {
        return (endTick - startTick) + 1;
      }
      
      getTickValueBasedOnPxlsToMove(amountOfTicks, pixelsToMove) {
        return pixelsToMove / amountOfTicks;
      }
      
      getTickPct(tick, amountOfTicks) {
        return MU.roundNumber(100 / amountOfTicks * tick, 1);
      }
      
      getClosestTick(pct, amountOfTicks) {
        let currentNumber = 0;
        
        let diff = pct;
        for (let tick = 1; tick <= amountOfTicks; tick++) {
          let tickPct = this.getTickPct(tick, amountOfTicks);
          
          let newDiff = Math.abs(pct - tickPct);
          if (newDiff < diff) {
            diff = newDiff;
            currentNumber = tick;
          }
        }
        return +currentNumber;
      }
      
      getLegsUsedInCurrentStroke(currentTickPct) {
        let sequenceTimings = this.gaits[this.iteration.gait].sequenceTimings,
            sequence = this.gaits[this.iteration.gait].sequence;
        
        // we begin from > 0 and end at 100 pct
        for (let i = 0; i < sequenceTimings.length; i++) {
          if (currentTickPct > sequenceTimings[i].startPct &&
              currentTickPct <= sequenceTimings[i].endPct)
            return sequence[i];
        }
        
        // not found. when currentTickPct === 0 or error
        return null;
      }
      
      runGenerator(tick = 1) {
        // prevent multiple invocation
        if (this.generatorInterval) {
          console.warn('Generator is already in progress');
          return;
        }
        
        if (tick > this.iteration.amountOfTicks) {
          console.warn('Specified tick is bigger that the amount in the iteration');
          return;
        }
        
        // iteration starts after N amount of time with tick 1
        this.generatorInterval = setInterval(() => {
          debugger;
          
          // TODO
          // generate tick value
          let payload = this.getNextTickValues(tick);
          
          // dispatch tick data
          store.dispatch({
            type: "SEQUENCE_SHIFTED_XY_BATCHED",
            payload: payload.tickValues,
            // currentTickPct: payload.currentTickPct,
            // currentTick: tick
            pct: payload.currentTickPct,
            tick: tick
          });
          
          // check if that was the last tick
          // and if loop === true start new iteration
          if (tick === this.iteration.amountOfTicks) {
            this.clearGeneratorInterval();
            
            // reset progress to 0% when the iteration is complete
            store.dispatch({
              type: "SEQUENCE_PROGRESS_PCT_CHANGED",
              // currentTickPct: 0,
              // currentTick: 0
              pct: 0,
              tick: 0
            });
            
            if (this.loop) this.runGenerator();
          }
          
          // update tick value for the next interval
          tick++;
          
        }, 1000 / this.iteration.tps);
      }
      
      clearGeneratorInterval() {
        clearInterval(this.generatorInterval);
        this.generatorInterval = undefined;
      }
      
      pauseGenerator() {
        this.clearGeneratorInterval();
      }
      
      runOrResumeGenerator() {
        this.runGenerator(this.iteration.currentTick + 1);
      }
      
      // UI
      
      computeStrokeDistance(legId, iterationMovementData) {
        let cursorX = iterationMovementData[legId].transverseCursorX,
            cursorY = iterationMovementData[legId].transverseCursorY,
            dist = MU.getDistance(cursorX, cursorY).toFixed(2);
        
        return dist;
      }
      
      computeStrokeTiming(legId, iterationGait) {
        let stroke = this.gaits[iterationGait].legTimings[legId];
        
        return `left: ${stroke.startPct}%;
                width: ${stroke.endPct - stroke.startPct}%;`;
      }

    }
    window.customElements.define(movementGenerator.is, movementGenerator);
  </script>
</dom-module>