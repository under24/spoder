<link rel="import" href="../../../../../bower_components/polymer/polymer-element.html">

<dom-module id="animation-view-base">
  <template>
    <style>
      #base {
        height: 1px;
        width: 1px;
        position: absolute;
      }
      #base::after {
        content: '';
        background: rgba(0, 0, 255, 0.25);
        width: 20px;
        height: 20px;
        display: inline-block;
        transform: translate(-50%,-50%);
        border-radius: 100%;
      }
      #coxa {
        position: absolute;
        top: 0px;
        height: 1px;
        background-color: black;
      }
      :host([side=left]) #coxa {
        transform-origin: left;
        left: 0px;
      }
      :host([side=right]) #coxa {
        transform-origin: right;
        right: 0px;
      }
      #baseRange {
        background-color: rgba(255, 0, 0, 0.04);
        display: inline-block;
        transform: translate(0%, -50%) rotate(-45deg);
        position: absolute;
        pointer-events: none;
        transform-origin: 0% 50%;
      }
      #baseInvalidRange {
        background-color: rgba(255, 0, 0, 0.04);
        border-radius: 100%;
        position: absolute;
        border: 1px solid transparent;
        transform: translate(-50%, -50%) rotateZ(-45deg) rotate(-45deg);
        pointer-events: none;
      }
      :host([side=left]) #baseInvalidRange {
        border-right-color: red;
        border-bottom-color: red;
      }
      :host([side=right]) #baseInvalidRange {
        border-left-color: red;
        border-top-color: red;
      }
      #aniCenter {
        position: absolute;
        height: 0px;
        width: 0px;
        background-color: black;
      }
      #aniCircle {
        display: inline-block;
        background-color: rgba(255, 0, 0, 0.1);
        transform: translate(-50%, -50%);
        border-radius: 100%;
      }
      #aniCenter::after {
        content: '';
        display: inline-block;
        width: 4px;
        height: 4px;
        transform: translate(-50%, -50%);
        background-color: black;
        border-radius: 100%;
        top: 50%;
        left: 50%;
        position: absolute;
      }
    </style>
    
    <div id="base">
      <div id="coxa"></div>
      <div id="baseRange"></div>
      <div id="baseInvalidRange"></div>
    </div>
    <div id="aniCenter">
      <div id="aniCircle"></div>
    </div>
  </template>

  <script>
    class animationViewBase extends ReduxMixin(Polymer.Element) {
      static get is() { return 'animation-view-base'; }
      static get properties() {
        return {
          side: {
            reflectToAttribute: true,
            observer: 'observeSide'
          },
          offsetX: Number,
          passedX: Number,
          x: {
            computed: 'computeX(offsetX, passedX)',
            observer: 'observeBaseX'
          },
          offsetY: Number,
          passedY: Number,
          y: {
            computed: 'computeY(offsetY, passedY)',
            observer: 'observeBaseY'
          },
          coxaScreenAngle: {
            observer: 'observeCoxaScreenAngle'
          },
          combinedLegsLength: {
            observer: 'observeCombinedLegsLength'
          },
          impossibleRange: {
            observer: 'observeImpossibleRange'
          },
          legLength: {
            observer: 'observeLegLength'
          },
          output: {
            notify: true
          },
          animationCenter: {
            observer: 'observeAnimationCenter'
          },
          animationRadius: {
            observer: 'observeAnimationRadius'
          },
          degOffset: {
            type: Number
          }
        };
      }
      
      connectedCallback() {
        super.connectedCallback();
        
        this.$.base.onmousedown = (e) => {
          this.clickCoords = {x: e.pageX,y: e.pageY};

          document.onmousemove = (e) => {
            let diffX = this.clickCoords.x - e.pageX;
            let diffY = this.clickCoords.y - e.pageY;
            
            // the position is the same
            if (diffX === 0 && diffY === 0) return;
            
            // filter out 0 value
            let payload = {};
            if (diffX !== 0) {
              switch (this.side) {
                case 'left':
                  payload.x = diffX;
                  break;
                case 'right':
                  payload.x = -diffX;
                  break;
              }
              this.clickCoords.x = e.pageX;
            }
            if (diffY !== 0) {
              payload.y = diffY;
              this.clickCoords.y = e.pageY;
            }
            
            // export data to the upper component
            this.output = payload;
            
            e.preventDefault();
            e.stopPropagation();
          };
          document.onmouseup = () => {
            document.onmousemove = null;
            document.onmouseup = null;
          }
          e.preventDefault();
          e.stopPropagation()
        }
      }
      
      observeCoxaScreenAngle(newAngle) {
        if (this.degOffset) {
          switch (this.side) {
            case 'left':
              this.$.coxa.style.transform = 'rotate(' + (newAngle + this.degOffset) + 'deg)';
              return;
            case 'right':
              this.$.coxa.style.transform = 'rotate(' + (newAngle + this.degOffset) * -1 + 'deg)';
              return;
          }
        }
        
        switch (this.side) {
          case 'left':
            this.$.coxa.style.transform = 'rotate(' + newAngle + 'deg)';
            return;
          case 'right':
            this.$.coxa.style.transform = 'rotate(' + newAngle * -1 + 'deg)';
            return;
        }
      }
      
      redrawX(x) {
        switch (this.side) {
          case 'left':
            this.$.base.style.left = x + 'px';
            return;
          case 'right':
            this.$.base.style.right = x + 'px';
            return;
        }
      }
      
      redrawY(y) {
        this.$.base.style.top = y + 'px';
      }
      
      redrawSide() {
        switch(this.side) {
          case 'left':
            this.$.baseRange.style.borderBottomLeftRadius = '';
            this.$.baseRange.style.borderTopLeftRadius = '';
            this.$.baseRange.style.right = '';
            
            this.$.baseRange.style.borderBottomRightRadius = this.combinedLegsLength * 2 + 'px';
            this.$.baseRange.style.borderTopRightRadius = this.combinedLegsLength * 2 + 'px';
            this.$.baseRange.style.left = '0px';
            
            this.$.base.style.right = '';
            this.redrawX(this.x);
            return;
          case 'right':
            this.$.baseRange.style.borderBottomRightRadius = '';
            this.$.baseRange.style.borderTopRightRadius = '';
            this.$.baseRange.style.left = '';
          
            this.$.baseRange.style.borderBottomLeftRadius = this.combinedLegsLength * 2 + 'px';
            this.$.baseRange.style.borderTopLeftRadius = this.combinedLegsLength * 2 + 'px';
            this.$.baseRange.style.right = '0px';
            
            this.$.base.style.left = '';
            this.redrawX(this.x);
            return;
        }
      }
      
      computeX(offsetX, passedX) {
        return offsetX ? offsetX + passedX : passedX;
      }
      
      computeY(offsetY, passedY) {
        return offsetY ? offsetY + passedY : passedY;
      }
      
      observeCombinedLegsLength(combinedLength) {
        this.$.baseRange.style.width = combinedLength + 'px';
        this.$.baseRange.style.height = combinedLength * 2 + 'px';
      }
      
      observeImpossibleRange(impRange) {
        this.$.baseInvalidRange.style.width = impRange * 2 + 'px';
        this.$.baseInvalidRange.style.height = impRange * 2 + 'px';
      }
      
      observeLegLength(length) {
        this.$.coxa.style.width = length + 'px';
      }
      
      observeAnimationRadius(radius) {
        this.$.aniCircle.style.width = radius + 'px';
        this.$.aniCircle.style.height = radius + 'px';
      }
      
      observeAnimationCenter() {
        let x = this.x;
        let y = this.y;
        let angle = this.degOffset;
        let distance = this.animationCenter;
        
        var result = {};

        result.x = Math.round(Math.cos(angle * Math.PI / 180) * distance + x);
        result.y = Math.round(Math.sin(angle * Math.PI / 180) * distance + y);

        this.$.aniCenter.style.left = result.x + 'px';
        this.$.aniCenter.style.top = result.y + 'px';
        
        return result;
      }

    }
    animationViewBase.prototype.observeBaseX = animationViewBase.prototype.redrawX;
    animationViewBase.prototype.observeBaseY = animationViewBase.prototype.redrawY;
    animationViewBase.prototype.observeSide = animationViewBase.prototype.redrawSide;

    window.customElements.define(animationViewBase.is, animationViewBase);
  </script>
</dom-module>
