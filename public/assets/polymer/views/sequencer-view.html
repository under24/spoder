<dom-module id="sequencer-view">
  <template>
    <style>
      :host {
        display: block;
        width: 100%;
        height: 100%;
        position: relative;
      }
      #sequenceTimeline {
        width: 95%;
        border: 1px dotted;
        margin: auto;
        box-sizing: border-box;
        position: relative;
        display: flex;
        flex-direction: column;
      }
      #sequenceTimeline .leg-sequence {
        font-size: 17px;
        display: flex;
        border-top: 1px dotted;
      }
      #sequenceTimeline .leg-sequence:first-child {
        border-top: none;
      }
      #sequenceTimeline .sequence-header {
        display: inline-block;
        border-right: 1px dotted;
        padding: 4px 0px 4px 8px;
        width: 48px;
        font-size: 16px;
      }
      #sequenceTimeline #cursor {
        width: 1px;
        background: black;
        position: absolute;
        display: inline-block;
        top: 0px;
        bottom: 0px;
      }
      #cursorKnob {
        position: absolute;
        top: 100%;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(128, 128, 128, 0.2);
        padding: 4px 8px 2px;
      }
      .sequence-content {
        flex: 1;
        position: relative;
      }
      .sequence-content .payload {
        position: absolute;
        background-color: rgba(0, 0, 0, 0.1);
        top: 0px;
        bottom: 0px;
        text-align: center;
        line-height: 26px;
      }
      .cursor-wrapper {
        position: absolute;
        top: 0px;
        bottom: 0px;
        left: 57px;
        right: 0px;
      }
      fieldset {
        width: 95%;
        box-sizing: border-box;
        margin: 10px auto;
        border-width: 0px;
        border-style: hidden;
      }
    </style>
    
    <label>
      <input type="checkbox" checked={{loop::click}} />
      Loop sequence
    </label>

    <br /><br /><br />
    
    <div id="sequenceTimeline">
      <!-- <div class="leg-sequence" id="leg1">
        <div class="sequence-header">Base</div>
        <div class="sequence-content">
          <div class="payload">25</div>
          <div class="payload">25</div>
          <div class="payload">25</div>
          <div class="payload">25</div>
        </div>
      </div>
      <hr /> -->
      <div class="leg-sequence" id="leg1">
        <div class="sequence-header">L1 (1)</div>
        <div class="sequence-content">
          <div class="payload" style$="[[computeStrokeTiming('1', iteration.gait)]]">[[computeStrokeDistance('1', blueprint)]]</div>
        </div>
      </div>
      <div class="leg-sequence" id="leg2">
        <div class="sequence-header">R1 (2)</div>
        <div class="sequence-content">
          <div class="payload" style$="[[computeStrokeTiming('2', iteration.gait)]]">[[computeStrokeDistance('2', blueprint)]]</div>
        </div>
      </div>
      <div class="leg-sequence" id="leg3">
        <div class="sequence-header">L2 (3)</div>
        <div class="sequence-content">
          <div class="payload" style$="[[computeStrokeTiming('3', iteration.gait)]]">[[computeStrokeDistance('3', blueprint)]]</div>
        </div>
      </div>
      <div class="leg-sequence" id="leg4">
        <div class="sequence-header">R2 (4)</div>
        <div class="sequence-content">
          <div class="payload" style$="[[computeStrokeTiming('4', iteration.gait)]]">[[computeStrokeDistance('4', blueprint)]]</div>
        </div>
      </div>
      <div class="leg-sequence" id="leg5">
        <div class="sequence-header">L3 (5)</div>
        <div class="sequence-content">
          <div class="payload" style$="[[computeStrokeTiming('5', iteration.gait)]]">[[computeStrokeDistance('5', blueprint)]]</div>
        </div>
      </div>
      <div class="leg-sequence" id="leg6">
        <div class="sequence-header">R3 (6)</div>
        <div class="sequence-content">
          <div class="payload" style$="[[computeStrokeTiming('6', iteration.gait)]]">[[computeStrokeDistance('6', blueprint)]]</div>
        </div>
      </div>
      
      <div class="cursor-wrapper">
        <div id="cursor" style$="left: [[iteration.currentTickPct]]%">
          <div id="cursorKnob">[[iteration.currentTickPct]]</div>
        </div>
      </div>

    </div>
    
    <br /><br />
    <fieldset>
      <legend>Blueprint</legend>
      <button type="button" on-click="onGenerateBlueprintButtonClicked">Generate Blueprint</button>
    </fieldset>
    <fieldset>
      <legend>Sequence</legend>
      <button type="button" on-click="onGenerateSequenceButtonClicked">Generate Sequence</button>
    </fieldset>
    <fieldset>
      <legend>Player</legend>
      <button type="button" on-click="playOrResumeSequence">Play / Resume</button>
      <button type="button" on-click="pauseSequence">Pause</button>
    </fieldset>
    
    
  </template>

  <script>
    class sequencerView extends ReduxMixin(Polymer.Element) {
      static get is() { return 'sequencer-view'; }
      static get properties() {
        return {
          baseCenterCoords: {
            statePath: 'base.centerCoords'
          },
          pointers: {
            statePath: 'movement.pointers',
            observer: 'observePointers'
          },
          circles: {
            statePath: 'movement.circles'
          },
          coords: {
            statePath: 'coords'
          },
          directionJoystick: {
            statePath: 'movement.directionJoystick'
          },
          turnJoystick: {
            statePath: 'movement.turnJoystick'
          },
          gaits: {
            statePath: 'gaits'
          },
          iteration: {
            statePath: 'movement.iteration'
          },
          movementSettings: {
            statePath: 'movement.settings'
          },
          loop: {
            value: true,
            // statePath: 'movement.settings.loop'
          }
        };
      }
      
      generateSequenceBlueprint() {
        let blueprint = {},
            iterationMovementData = {},
            selectedGait = this.iteration.currentTick === 0 ? this.movementSettings.gait : this.iteration.gait || this.movementSettings.gait;
        
        for (let legId = 1; legId <= 6; legId++) {
          iterationMovementData[legId] = this.getIterationMovementData(legId);
          // save leg timings for constructing the blueprint
          let legTimings = this.gaits[selectedGait].legTimings[legId];
          // make a blueprint
          blueprint[legId] = this.fillInBlueprintData(legId, legTimings, iterationMovementData);
        }
        
        return blueprint;
      }
      
      getIterationMovementData(legId) {
        return {
          transverseBaseX: this.circles[legId].fluentX - this.pointers[legId].x,
          transverseBaseY: this.circles[legId].fluentY - this.pointers[legId].y,
          transverseCursorX: this.coords[legId].transverseCursorX - this.pointers[legId].x,
          transverseCursorY: this.coords[legId].transverseCursorY - this.pointers[legId].y
        };
      }
      
      fillInBlueprintData(legId, legTimings, iterationMovementData) {
        return [
          {
            "coordType": "transverseBaseX",
            "startPct": 0,
            "endPct": 100,
            "pxlsToMove": iterationMovementData[legId].transverseBaseX
          },
          {
            "coordType": "transverseBaseY",
            "startPct": 0,
            "endPct": 100,
            "pxlsToMove": iterationMovementData[legId].transverseBaseY
          },
          {
            "coordType": "transverseCursorX",
            "startPct": legTimings.startPct,
            "endPct": legTimings.endPct,
            "pxlsToMove": iterationMovementData[legId].transverseCursorX
          },
          {
            "coordType": "transverseCursorY",
            "startPct": legTimings.startPct,
            "endPct": legTimings.endPct,
            "pxlsToMove": iterationMovementData[legId].transverseCursorY
          },
          {
            coordType: "sagittalCursorY",
            startPct: legTimings.startPct,
            endPct: legTimings.startPct + ((legTimings.endPct - legTimings.startPct) / 2),
            pxlsToMove: 25
          },
          {
            coordType: "sagittalCursorY",
            startPct: legTimings.endPct - ((legTimings.endPct - legTimings.startPct) / 2),
            endPct: legTimings.endPct,
            pxlsToMove: -25
          }
        ];
      }
      
      onGenerateBlueprintButtonClicked() {
        this.blueprint = this.generateSequenceBlueprint();
      }
      
      onGenerateSequenceButtonClicked() {
        this.sequence = SU.generateSequenceTimeline(this.blueprint, this.iteration.tps, this.iteration.duration, this.iteration.amountOfTicks);
      }
      
      pauseSequence() {
        this.clearSequenceInterval();
      }
      
      clearSequenceInterval() {
        clearInterval(this.sequenceInterval);
        this.sequenceInterval = undefined;
      }
      
      playOrResumeSequence() {
        this.runSequence(this.iteration.currentTick + 1);
      }
      
      observePointers(newValue, oldValue) {
        // if init (values are nulls) then quit and wait for the next update
        if (newValue[1] === null) return;
        
        if (this.prevDirectionJoystick !== this.directionJoystick) {
          this.prevDirectionJoystick = this.directionJoystick;
          this.prevTurnJoystick = this.turnJoystick;
          this.processNewIterationData();
        }
        else if (this.prevTurnJoystick !== this.turnJoystick) {
          this.prevTurnJoystick = this.turnJoystick;
          this.prevDirectionJoystick = this.directionJoystick;
          this.processNewIterationData();
        }
      }
      
      processNewIterationData() {
        this.onGenerateBlueprintButtonClicked();
        this.onGenerateSequenceButtonClicked();
      }
      
      runSequence(tick = 1) {
        // prevent multiple invocation
        if (this.sequenceInterval) {
          console.warn('another sequence is in progress');
          return;
        }
        
        this.sequenceInterval = setInterval(() => {
          
          // apply movement.turnJoystick values
          if (this.turnJoystick.normalizedX) {
            // angle / amount of ticks = angle for each tick
            let stepAngle = this.turnJoystick.normalizedX / this.sequence.metaData.amountOfTicks;
            
            for (let legId = 1; legId <= 6; legId++) {
              // find rotated base coords
              let rotatedCoords = MU.getRotatedCoords(this.baseCenterCoords, MU.flipNumber(stepAngle), this.coords[legId]);
              // get shift values from actual coords
              let shiftX = this.coords[legId].transverseBaseX - rotatedCoords.x,
                  shiftY = this.coords[legId].transverseBaseY - rotatedCoords.y;
              // add turn values to the payload
              this.sequence.timeline[tick].payload[legId].transverseBaseX += shiftX;
              this.sequence.timeline[tick].payload[legId].transverseBaseY += shiftY;
            }
          }
          
          store.dispatch({
            type: "SEQUENCE_SHIFTED_XY_BATCHED",
            payload: this.sequence.timeline[tick].payload,
            currentTick: tick,
            currentTickPct: this.sequence.timeline[tick].pct
          });
          
          // sequence complete
          if (tick >= this.sequence.metaData.amountOfTicks) {
            this.clearSequenceInterval();

            // reset iteration tick and tickPct to 0
            store.dispatch({
              type: "MOVEMENT_ITERATION_VALUES_CHANGED",
              payload: { currentTick: 0, currentTickPct: 0 }
            });
            
            // if loop === true, create a new sequence and run it
            if (this.loop) {
              this.processNewIterationData();
              this.runSequence();
            }
          }
          
          // update next tick value
          tick++;
          
        }, 1000 / this.sequence.metaData.tps);
      }
      
      // UI
      
      computeStrokeTiming(legId, iterationGait) {
        if (iterationGait === null) return;
        
        let legStroke = this.gaits[iterationGait].legTimings[legId];
        
        return `left: ${legStroke.startPct}%;
                width: ${legStroke.endPct - legStroke.startPct}%;`;
      }
      
      // TODO
      computeStrokeDistance(legId, blueprint) {
        let dx = this.coords[legId].transverseCursorX - this.pointers[legId].x,
            dy = this.coords[legId].transverseCursorY - this.pointers[legId].y,
            dist = MU.getDistance(dx, dy).toFixed(2);
            
        return dist;
      }

    }
    window.customElements.define(sequencerView.is, sequencerView);
  </script>
</dom-module>