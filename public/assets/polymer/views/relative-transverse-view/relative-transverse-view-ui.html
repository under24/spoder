<dom-module id="relative-transverse-view-ui">
  <template>
    <style>
      #base {
        height: 0px;
        width: 0px;
        position: absolute;
      }
      #base::after {
        content: '';
        background: rgba(0, 0, 255, 0.25);
        width: 20px;
        height: 20px;
        display: inline-block;
        transform: translate(-50%,-50%);
        border-radius: 100%;
      }
      .coxa {
        position: absolute;
        top: 0px;
        height: 1px;
        background-color: black;
        z-index: 1;
        pointer-events: none;
      }
      :host([side=left]) .coxa {
        transform-origin: left;
        left: 0px;
      }
      :host([side=right]) .coxa {
        transform-origin: right;
        right: 0px;
      }
      .reachRadius {
        background-color: rgba(255, 0, 0, 0.04);
        display: inline-block;
        position: absolute;
        pointer-events: none;
      }
      :host([side=left]) .reachRadius {
        left: 0px;
        transform-origin: center left;
      }
      :host([side=right]) .reachRadius {
        right: 0px;
        transform-origin: center right;
      }
      .baseInvalidRange {
        background-color: white;
        border-radius: 100%;
        position: absolute;
        border: 1px solid transparent;
        pointer-events: none;
        box-sizing: border-box;
      }
      :host([side=left]) .baseInvalidRange {
        border-right-color: red;
        border-bottom-color: red;
      }
      :host([side=right]) .baseInvalidRange {
        border-left-color: red;
        border-top-color: red;
      }
      .movementCircleCenter {
        position: absolute;
        height: 0px;
        width: 0px;
        pointer-events: none;
      }
      .movementCircle {
        display: inline-block;
        background-color: rgba(255, 0, 0, 0.1);
        transform: translate(-50%, -50%);
        border-radius: 100%;
      }
      .movementCircleCenter::after {
        content: '';
        display: inline-block;
        width: 4px;
        height: 4px;
        transform: translate(-50%, -50%);
        background-color: black;
        border-radius: 100%;
        top: 50%;
        left: 50%;
        position: absolute;
      }
      .movementPointer {
        content: '';
        background: rgba(0, 128, 0, 0.35);
        width: 20px;
        height: 20px;
        display: inline-block;
        border-radius: 100%;
        position: absolute;
      }
      :host([side=left]) .movementPointer {
        transform: translate(-50%,-50%);
      }
      :host([side=right]) .movementPointer {
        transform: translate(50%,-50%);
      }
    </style>
    
    <div id="base" style$="[[computeBase(xy, side)]]">
      <div class="coxa" style$="width: [[legLength]]px; transform: rotate([[coxaScreenAngle]]deg"></div>
      <div class="reachRadius" style$="[[computeReachRadius(reachRadius, baseCoxaAngle, side)]]"></div>
      <div class="baseInvalidRange" style$="[[computeBaseInvalidRange(baseCoxaAngle, impossibleRange)]]"></div>
    </div>
    
    <div class="movementCircleCenter" style$="[[computeMovementCircleCenter(movementCenterCoords, side)]]">
      <div class="movementCircle" style$="[[computeMovementCircle(movementCircleDiameter)]]"></div>
    </div>
    
    <div class="movementPointer" style$="[[computeMovementPointer(movementPointer, side)]]"></div>
  </template>

  <script>
    class relativeTransverseViewUi extends ReduxMixin(Polymer.Element) {
      static get is() { return 'relative-transverse-view-ui'; }
      static get properties() {
        return {
          side: {
            reflectToAttribute: true
          },
          xy: Object,
          coxaScreenAngle: Number,
          reachRadius: Number,
          impossibleRange: Number,
          legLength: Number,
          movementCenterCoords: Object,
          movementCircleDiameter: Number,
          baseCoxaAngle: Number,
          movementPointer: Object,
          output: {
            notify: true
          }
        };
      }
      
      connectedCallback() {
        super.connectedCallback();
        
        this.$.base.onmousedown = e => {
          this.clickCoords = { x: e.pageX,y: e.pageY };

          document.onmousemove = e => {
            let diffX = this.clickCoords.x - e.pageX;
            let diffY = this.clickCoords.y - e.pageY;
            
            // the position is the same
            if (diffX === 0 && diffY === 0) return;
            
            // filter out 0 value
            let payload = {};
            if (diffX !== 0) {
              switch (this.side) {
                case 'left':
                  payload.x = diffX; break;
                case 'right':
                  payload.x = -diffX; break;
              }
              this.clickCoords.x = e.pageX;
            }
            if (diffY !== 0) {
              payload.y = diffY;
              this.clickCoords.y = e.pageY;
            }
            
            // export data to the upper component
            this.output = payload;
            
            e.preventDefault();
            e.stopPropagation();
          };
          document.onmouseup = () => {
            document.onmousemove = null;
            document.onmouseup = null;
          }
          e.preventDefault();
          e.stopPropagation()
        }
      }
      
      computeBase(coords, side) {
        switch (side) {
          case 'left':
            var x = `left: ${coords.x}px;`; break;
          case 'right':
            var x = `right: ${coords.x}px;`; break;
        }
        
        var y = `top: ${coords.y}px;`;
        
        return x + y;
      }
      
      computeMovementCircleCenter(movementCenterCoords, side) {
        switch (side) {
          case 'left':
            var x = `left: ${movementCenterCoords.x}px;`; break;
          case 'right':
            var x = `right: ${movementCenterCoords.x}px;`; break;
        }
        
        var y = `top: ${movementCenterCoords.y}px;`;
        
        return x + y;
      }
      
      computeMovementCircle(movementCircleDiameter) {
        var width = `width: ${movementCircleDiameter}px;`;
        var height = `height: ${movementCircleDiameter}px;`;
        
        return width + height;
      }
      
      computeBaseInvalidRange(baseCoxaAngle, impossibleRange) {
        var transform = `transform: translate(-50%, -50%) rotateZ(-45deg) rotate(${baseCoxaAngle}deg);`;
        
        var width = `width: ${impossibleRange * 2}px;`;
        var height = `height: ${impossibleRange * 2}px;`;
        
        return transform + width + height;
      }
      
      computeReachRadius(reachRadius, baseCoxaAngle, side) {
        var width = `width: ${reachRadius}px;`;
        var height = `height: ${reachRadius * 2}px;`;
        
        var transform = `transform: translate(0%, -50%) rotate(${baseCoxaAngle}deg);`;
        
        switch (side) {
          case 'left':
            var borderTopX = `border-top-right-radius: ${reachRadius * 2}px;`;
            var borderBottomX = `border-bottom-right-radius: ${reachRadius * 2}px;`;
            break;
          case 'right':
            var borderTopX = `border-top-left-radius: ${reachRadius * 2}px;`;
            var borderBottomX = `border-bottom-left-radius: ${reachRadius * 2}px;`;
            break;
        }
        
        return width + height + transform + borderTopX + borderBottomX;
      }
      
      computeMovementPointer(movementPointer, side) {
        switch (side) {
          case 'left':
            var x = `left: ${movementPointer.x}px;`; break;
          case 'right':
            var x = `right: ${movementPointer.x}px;`; break;
        }
        
        var y = `top: ${movementPointer.y}px;`;
        
        return x + y;
      }

    }
    window.customElements.define(relativeTransverseViewUi.is, relativeTransverseViewUi);
  </script>
</dom-module>