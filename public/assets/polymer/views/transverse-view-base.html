<dom-module id="transverse-view-base">
  <template>
    <style>
      #base {
        height: 1px;
        width: 1px;
        position: absolute;
      }
      :host([side=left]) #base {
        right: initial !important;
      }
      :host([side=right]) #base {
        left: initial !important;
      }
      #base::after {
        content: '';
        background: rgba(0, 0, 255, 0.25);
        width: 20px;
        height: 20px;
        display: inline-block;
        transform: translate(-50%,-50%);
        border-radius: 100%;
      }
      #coxa {
        position: absolute;
        top: 0px;
        height: 1px;
        background-color: black;
        z-index: 1;
        pointer-events: none;
      }
      :host([side=left]) #coxa {
        transform-origin: left;
        left: 0px;
      }
      :host([side=right]) #coxa {
        transform-origin: right;
        right: 0px;
      }
      #reachRadius {
        background-color: rgba(255, 0, 0, 0.04);
        display: inline-block;
        position: absolute;
        pointer-events: none;
      }
      :host([side=left]) #reachRadius {
        border-bottom-left-radius: initial !important;
        border-top-left-radius: initial !important;
        left: 0px;
        transform-origin: center left;
      }
      :host([side=right]) #reachRadius {
        border-bottom-right-radius: initial !important;
        border-top-right-radius: initial !important;
        right: 0px;
        transform-origin: center right;
      }
      #baseInvalidRange {
        background-color: white;
        border-radius: 100%;
        position: absolute;
        border: 1px solid transparent;
        pointer-events: none;
        box-sizing: border-box;
      }
      :host([side=left]) #baseInvalidRange {
        border-right-color: red;
        border-bottom-color: red;
      }
      :host([side=right]) #baseInvalidRange {
        border-left-color: red;
        border-top-color: red;
      }
      #movementCircleCenter {
        position: absolute;
        height: 0px;
        width: 0px;
        pointer-events: none;
      }
      :host([side=left]) #movementCircleCenter {
        right: initial !important;
      }
      :host([side=right]) #movementCircleCenter {
        left: initial !important;
      }
      #movementCircle {
        display: inline-block;
        background-color: rgba(255, 0, 0, 0.1);
        transform: translate(-50%, -50%);
        border-radius: 100%;
      }
      #movementCircleCenter::after {
        content: '';
        display: inline-block;
        width: 4px;
        height: 4px;
        transform: translate(-50%, -50%);
        background-color: black;
        border-radius: 100%;
        top: 50%;
        left: 50%;
        position: absolute;
      }
      #movementPointer {
        content: '';
        background: rgba(0, 128, 0, 0.35);
        width: 20px;
        height: 20px;
        display: inline-block;
        border-radius: 100%;
        position: absolute;
      }
      :host([side=left]) #movementPointer {
        right: initial !important;
        transform: translate(-50%,-50%);
      }
      :host([side=right]) #movementPointer {
        left: initial !important;
        transform: translate(50%,-50%);
      }
    </style>
    
    <div id="base" style$="[[computeBase(x, y, side)]]">
      <div id="coxa" style$="[[computeCoxa(legLength, coxaScreenAngle, side)]]"></div>
      <div id="reachRadius" style$="[[computeReachRadius(reachRadius, baseCoxaAngle, side)]]"></div>
      <div id="baseInvalidRange" style$="[[computeBaseInvalidRange(baseCoxaAngle, impossibleRange)]]"></div>
    </div>
    
    <div id="movementCircleCenter" style$="[[computeMovementCircleCenter(movementCenterCoords, side)]]">
      <div id="movementCircle" style$="[[computeMovementCircle(movementCircleDiameter)]]"></div>
    </div>
    
    <div id="movementPointer" style$="[[computeMovementPointer(movementPointer, side)]]"></div>
  </template>

  <script>
    class transverseViewBase extends ReduxMixin(Polymer.Element) {
      static get is() { return 'transverse-view-base'; }
      static get properties() {
        return {
          side: {
            reflectToAttribute: true
          },
          x: Number,
          y: Number,
          coxaScreenAngle: Number,
          reachRadius: Number,
          impossibleRange: Number,
          legLength: Number,
          movementCenterCoords: Object,
          movementCircleDiameter: Number,
          baseCoxaAngle: Number,
          movementPointer: Object,
          output: {
            notify: true
          }
        };
      }
      
      connectedCallback() {
        super.connectedCallback();
        
        this.$.base.onmousedown = e => {
          this.clickCoords = { x: e.pageX,y: e.pageY };

          document.onmousemove = e => {
            let diffX = this.clickCoords.x - e.pageX;
            let diffY = this.clickCoords.y - e.pageY;
            
            // the position is the same
            if (diffX === 0 && diffY === 0) return;
            
            // filter out 0 value
            let payload = {};
            if (diffX !== 0) {
              switch (this.side) {
                case 'left':
                  payload.x = diffX; break;
                case 'right':
                  payload.x = -diffX; break;
              }
              this.clickCoords.x = e.pageX;
            }
            if (diffY !== 0) {
              payload.y = diffY;
              this.clickCoords.y = e.pageY;
            }
            
            // export data to the upper component
            this.output = payload;
            
            e.preventDefault();
            e.stopPropagation();
          };
          document.onmouseup = () => {
            document.onmousemove = null;
            document.onmouseup = null;
          }
          e.preventDefault();
          e.stopPropagation()
        }
      }
      
      computeBase(x, y, side) {
        switch (side) {
          case 'left':
            var x = `left: ${x}px;`; break;
          case 'right':
            var x = `right: ${x}px;`; break;
        }
        
        var y = `top: ${y}px;`;
        
        return x + y;
      }
      
      computeMovementCircleCenter(movementCenterCoords, side) {
        switch (side) {
          case 'left':
            var x = `left: ${movementCenterCoords.x}px;`; break;
          case 'right':
            var x = `right: ${movementCenterCoords.x}px;`; break;
        }
        
        var y = `top: ${movementCenterCoords.y}px;`;
        
        return x + y;
      }
      
      computeMovementCircle(movementCircleDiameter) {
        var width = `width: ${movementCircleDiameter}px;`;
        var height = `height: ${movementCircleDiameter}px;`;
        
        return width + height;
      }
      
      computeBaseInvalidRange(baseCoxaAngle, impossibleRange) {
        var transform = `transform: translate(-50%, -50%) rotateZ(-45deg) rotate(${baseCoxaAngle}deg);`;
        
        var width = `width: ${impossibleRange * 2}px;`;
        var height = `height: ${impossibleRange * 2}px;`;
        
        return transform + width + height;
      }
      
      computeReachRadius(reachRadius, baseCoxaAngle, side) {
        var width = `width: ${reachRadius}px;`;
        var height = `height: ${reachRadius * 2}px;`;
        
        var transform = `transform: translate(0%, -50%) rotate(${baseCoxaAngle}deg);`;
        
        switch (side) {
          case 'left':
            var borderTopX = `border-top-right-radius: ${reachRadius * 2}px;`;
            var borderBottomX = `border-bottom-right-radius: ${reachRadius * 2}px;`;
            break;
          case 'right':
            var borderTopX = `border-top-left-radius: ${reachRadius * 2}px;`;
            var borderBottomX = `border-bottom-left-radius: ${reachRadius * 2}px;`;
            break;
        }
        
        return width + height + transform + borderTopX + borderBottomX;
      }
      
      computeCoxa(legLength, coxaScreenAngle, side) {
        var width = `width: ${legLength}px;`;
        
        switch (side) {
          case 'left':
            var transform = `transform: rotate(${coxaScreenAngle}deg);`; break;
          case 'right':
            var transform = `transform: rotate(${MU.flipNumber(coxaScreenAngle)}deg);`; break;
        }
        
        return width + transform;
      }
      
      computeMovementPointer(movementPointer, side) {
        switch (side) {
          case 'left':
            var x = `left: ${movementPointer.x}px;`; break;
          case 'right':
            var x = `right: ${movementPointer.x}px;`; break;
        }
        
        var y = `top: ${movementPointer.y}px;`;
        
        return x + y;
      }

    }
    window.customElements.define(transverseViewBase.is, transverseViewBase);
  </script>
</dom-module>