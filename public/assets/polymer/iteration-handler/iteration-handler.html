<link rel="import" href="../../../../../bower_components/polymer/polymer-element.html">

<dom-module id="iteration-handler">
  <script>
    class iterationHandler extends ReduxMixin(Polymer.Element) {
      static get is() { return 'iteration-handler'; }
      static get properties() {
        return {
          circles: {
            statePath: 'movement.circles'
          },
          iteration: {
            statePath: 'movement.iteration'
          },
          iterationTick: {
            statePath: 'movement.iteration.currentTick',
            observer: 'observeIterationTick'
          },
          settings: {
            statePath: 'movement.settings',
            observer: 'observeSettings'
          },
          pointers: {
            statePath: 'movement.pointers',
            observer: 'observePointers'
          },
          coords: {
            statePath: 'coords'
          },
          gaits: {
            statePath: 'gaits'
          },
          directionJoystick: {
            statePath: 'movement.directionJoystick'
          },
          turnJoystick: {
            statePath: 'movement.turnJoystick'
          }
        };
      }
      
      generateBlueprint() {
        let blueprint = {},
            iterationMovementData = {},
            selectedGait = this.iteration.currentTick === 0 ? this.settings.gait : this.iteration.gait || this.settings.gait;
        
        for (let legId = 1; legId <= 6; legId++) {
          iterationMovementData[legId] = this.getIterationMovementData(legId);
          // save leg timings for constructing the blueprint
          let legTimings = this.gaits[selectedGait].legTimings[legId];
          // make a blueprint
          blueprint[legId] = this.fillInBlueprintData(legId, legTimings, iterationMovementData);
        }
        
        let blueprintDataSource = {
          directionX: this.directionJoystick.x,
          directionY: this.directionJoystick.y,
          turnX: this.turnJoystick.x
        }
        
        this.dispatchIterationData(blueprint, blueprintDataSource);
      }
      
      getIterationMovementData(legId) {
        return {
          transverseBaseX: this.circles[legId].x - this.pointers[legId].x,
          transverseBaseY: this.circles[legId].y - this.pointers[legId].y,
          transverseCursorX: this.coords[legId].transverseCursorX - this.pointers[legId].x,
          transverseCursorY: this.coords[legId].transverseCursorY - this.pointers[legId].y
        };
      }
      
      fillInBlueprintData(legId, legTimings, iterationMovementData) {
        return [
          {
            "coordType": "transverseBaseX",
            "startPct": 0,
            "endPct": 100,
            "pxlsToMove": iterationMovementData[legId].transverseBaseX
          },
          {
            "coordType": "transverseBaseY",
            "startPct": 0,
            "endPct": 100,
            "pxlsToMove": iterationMovementData[legId].transverseBaseY
          },
          {
            "coordType": "transverseCursorX",
            "startPct": legTimings.startPct,
            "endPct": legTimings.endPct,
            "pxlsToMove": iterationMovementData[legId].transverseCursorX
          },
          {
            "coordType": "transverseCursorY",
            "startPct": legTimings.startPct,
            "endPct": legTimings.endPct,
            "pxlsToMove": iterationMovementData[legId].transverseCursorY
          }
        ];
      }
      
      dispatchIterationData(blueprint, blueprintDataSource) {
        let payload = { blueprint, blueprintDataSource };
        
        // when the iteration is complete or has not been started
        if (this.iterationTick === 0) {
          // try to pick up new properties (if there are) from movement.settings
          this.joinSettingsWithIteration(payload);
            
          store.dispatch({ type: "MOVEMENT_ITERATION_VALUES_CHANGED", payload });
        }
        // new settings can't be applied in mid iteration
        else
          store.dispatch({ type: "MOVEMENT_ITERATION_VALUES_CHANGED", payload });
      }
      
      joinSettingsWithIteration(payload) {
        let amountOfTicks = +(this.settings.duration / (1000 / this.settings.tps)).toFixed(0);
        
        if (this.iteration.tps === null || this.iteration.tps !== this.settings.tps)
          payload.tps = this.settings.tps;
          
        if (this.iteration.duration === null || this.iteration.duration !== this.settings.duration)
          payload.duration = this.settings.duration;
          
        if (this.iteration.gait === null || this.iteration.gait !== this.settings.gait)
          payload.gait = this.settings.gait;
          
        if (this.iteration.amountOfTicks === null || this.iteration.amountOfTicks !== amountOfTicks)
          payload.amountOfTicks = amountOfTicks;
      }
      
      observePointers(newValue, oldValue) {
        // if init data then quit and wait for the next update
        if (oldValue === undefined) return;
        
        let initialized = !(this.iteration.blueprintDataSource === null);
        if (!initialized) {
          this.generateBlueprint();
          return;
        }
        
        let sameValues = (this.turnJoystick.x === this.iteration.blueprintDataSource.turnX &&
                     this.directionJoystick.x === this.iteration.blueprintDataSource.directionX &&
                     this.directionJoystick.y === this.iteration.blueprintDataSource.directionY);
        if (!sameValues) this.generateBlueprint();
      }
      
      // this function also pick up new settings when the current iteration is complete
      observeIterationTick(newCurrentTick) {
        if (newCurrentTick === 0) this.generateBlueprint();
      }
      
      // if you change the settings and the currentTick is 0
      // then re-render blueprint + update the ui
      observeSettings(newSettings, oldSettings) {
        // skip init. the blueprint is going to be generated anyway
        if (oldSettings === undefined) return;
        
        // only settings.gait can influence the data of the blueprint
        if (this.iterationTick === 0 && newSettings.gait !== oldSettings.gait)
          this.generateBlueprint();
        // if there is no need to generate blueprint then pick up new data and dispatch without blueprint
        else if (this.iterationTick === 0 && newSettings.tps !== oldSettings.tps || newSettings.duration !== oldSettings.duration) {
          let payload = {};
          this.joinSettingsWithIteration(payload);
          
          store.dispatch({ type: "MOVEMENT_ITERATION_VALUES_CHANGED", payload });
        }
      }

    }
    window.customElements.define(iterationHandler.is, iterationHandler);
  </script>
</dom-module>