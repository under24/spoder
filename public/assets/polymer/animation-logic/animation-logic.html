<link rel="import" href="../../../../../bower_components/polymer/polymer-element.html">

<dom-module id="animation-logic">
  <script>
    class animationLogic extends ReduxMixin(Polymer.Element) {
      static get is() { return 'animation-logic'; }
      static get properties() {
        return {
          tps: {
            type: Number,
            value: 10
          },
          timelineDuration: {
            type: Number,
            value: 1000
          },
          overrideTiming: {
            type: Boolean,
            value: false
          },
          debug: {
            type: Boolean,
            value: true
          }
        };
      }
      
      generateAnimationTimeline(dataArr, tps = this.tps, timelineDuration = this.timelineDuration) {
        // override passed values
        if (this.overrideTiming) {
          tps = this.tps;
          timelineDuration = this.timelineDuration;
        }
        
        let amountOfTicks = this.getAmountOfTicks(tps, timelineDuration);
        let timeline = this.createTimeline(amountOfTicks);
        
        for (let i = 0; i < dataArr.length; i++) {
          this.populateTimeline(dataArr[i], timeline);
        }
        
        return {timeline, tps, timelineDuration, amountOfTicks};
      }
      
      getAmountOfTicks(tps, timelineDuration) {
        let amountOfTicks = timelineDuration / (1000 / tps);
        return Utils.roundNumber(amountOfTicks, 0);
      }
      
      createTimeline(amountOfTicks) {
        let timeline = Object.create(null);
        
        for (let i = 1; i <= amountOfTicks; i++) {
          timeline[i] = {
            pct: Utils.roundNumber(100 / amountOfTicks * i, 1),
            payload: Object.create(null)
          };
        }
        
        return timeline;
      }
      
      populateTimeline(data, timeline) {
        let startTick = this.getClosestTick(data.startPct, timeline) + 1;
        let endTick = this.getClosestTick(data.endPct, timeline);
        
        let ticksBetweenStartAndEnd = this.getAmountOfTicksBetween(startTick, endTick);
        
        let tickValue = this.calcTickValueBasedOnPxlsToMove(ticksBetweenStartAndEnd, data.pxlsToMove);

        this.pushDataToTimeline(startTick, endTick, data.coordType, tickValue, timeline);
      }
      
      getClosestTick(num, timeline) {
        let currentNumber = 0;
        
        let diff = num;
        for (let key in timeline) {
          let newDiff = Math.abs(num - timeline[key].pct);
          if (newDiff < diff) {
            diff = newDiff;
            currentNumber = key;
          }
        }
        return +currentNumber;
      }
      
      getAmountOfTicksBetween(startTick, endTick) {
        return (endTick - startTick) + 1;
      }
      
      calcTickValueBasedOnPxlsToMove(amountOfTicks, pixelsToMove) {
        return pixelsToMove / amountOfTicks;
      }
      
      pushDataToTimeline(startTick, endTick, coordType, value, timeline) {
        for (let i = startTick; i <= endTick; i++) {
          timeline[i].payload[coordType] = value;
        }
      }
      
      playTimeline(data) {
        // debugger;
        let startTime = +new Date();

        let n = 1;
        let interval = window.setInterval(() => {
          
          if (this.debug) {
            console.log('tick:', n, data.timeline[n].pct + "%", 'at', +new Date() - startTime, 'ms');
            this.logger(data.timeline[n].payload);
            console.log('----------------------');
          }
          
          // complete
          if (n >= data.amountOfTicks) {
            window.clearInterval(interval);
            
            if (this.debug) {
              console.log('Done ticking at', n);
              console.log('Time passed:',+new Date() - startTime);
            }
          }
          n++;
        }, 1000 / data.tps);
        
      }
      
      logger(payload) {
        for (let coordType in payload) {
          console.log(coordType, payload[coordType]);
          
          if (payload.sagittalCursorY) {
            store.dispatch({
              type: "CURSOR_XY_SHIFTED",
              legId: 1,
              payload: {[coordType]: payload.sagittalCursorY}
            });
          }
          
          if (payload.sagittalBaseY) {
            store.dispatch({
              type: "CURSOR_XY_SHIFTED",
              legId: 1,
              payload: {transverseCursorY: payload.sagittalBaseY}
            });
          }

        }
      }

    }

    window.customElements.define(animationLogic.is, animationLogic);
  </script>
</dom-module>